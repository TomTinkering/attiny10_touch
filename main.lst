   1               		.file	"main.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x3c
   6               	__tmp_reg__ = 16
   7               	__zero_reg__ = 17
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  10               		.text
  11               	.Ltext0:
  12               		.cfi_sections	.debug_frame
  13               	.global	init
  15               	init:
  16               	.LFB7:
  17               		.file 1 "main.c"
   1:main.c        **** #include <util/delay.h>
   2:main.c        **** #include <avr/io.h>
   3:main.c        **** #include <avr/interrupt.h>
   4:main.c        **** 
   5:main.c        **** #define TRUE (1)
   6:main.c        **** #define FALSE (0)
   7:main.c        **** 
   8:main.c        **** #define CAP_TOUCH_PIN (PIN1) //TODO: set proper pin
   9:main.c        **** 
  10:main.c        **** #define OCR_INCREMENT ((uint16_t)417)
  11:main.c        **** 
  12:main.c        **** 
  13:main.c        **** void init(void);
  14:main.c        **** 
  15:main.c        **** 
  16:main.c        **** //the number of instructions before INT0 is executed
  17:main.c        **** #define ISR_OFFSET     (4+10) //4 till call, 10 till instruction
  18:main.c        **** 
  19:main.c        **** //next sample instant 1/19200 = 52us =~ 417 tim-ticks @ 8MHz
  20:main.c        **** #define UART_BIT_TIME       ((uint16_t)417) //number of clock ticks @8MHz per bit
  21:main.c        **** 
  22:main.c        **** #define UART_OCR_OFFSET     (4+10) //4 till call, 10 till instruction
  23:main.c        **** #define UART_OCR_INC        ((UART_BIT_TIME / 2)-UART_OCR_OFFSET)
  24:main.c        **** #define UART_HALF_OCR_INC   (UART_BIT_TIME-UART_OCR_OFFSET)
  25:main.c        **** 
  26:main.c        **** #define UART_RX_PIN    (PB0)
  27:main.c        **** #define UART_TX_PIN    (PB1)
  28:main.c        **** #define UART_START     (0)
  29:main.c        **** #define UART_STOP      (9)
  30:main.c        **** 
  31:main.c        **** //protocol definitions
  32:main.c        **** #define SLOT_TAKEN_BIT (7)
  33:main.c        **** 
  34:main.c        **** uint16_t       cur_meas;
  35:main.c        **** uint8_t cur_conf,cur_touch;
  36:main.c        **** uint8_t cur_rx,cur_tx,tx_cnt;
  37:main.c        **** 
  38:main.c        **** int main(void) {
  39:main.c        **** 
  40:main.c        ****   init();
  41:main.c        **** 
  42:main.c        ****   while(TRUE){
  43:main.c        **** 
  44:main.c        ****       //if uart cycle has completed (both interrupts disabled) prepare next
  45:main.c        ****       if( ( EIMSK & (1 << INT0) ) && ( TIMSK0 & (1 << OCIE0A) ) )
  46:main.c        ****       {
  47:main.c        **** 
  48:main.c        ****           //check if  is for us
  49:main.c        ****           if(cur_rx & (1 << SLOT_TAKEN_BIT)){
  50:main.c        ****               //if for us, store settings, refresh button state
  51:main.c        ****               cur_conf = cur_rx;
  52:main.c        ****               cur_tx = cur_rx | (1<<SLOT_TAKEN_BIT) | cur_touch;
  53:main.c        ****           } else {
  54:main.c        ****               //if not for us pass on untouched
  55:main.c        ****               cur_tx = cur_rx;
  56:main.c        ****           }
  57:main.c        **** 
  58:main.c        ****           //go to uart idle state (enable EXTI)
  59:main.c        ****           EIMSK = (1 << INT0);
  60:main.c        **** 
  61:main.c        ****       }
  62:main.c        **** 
  63:main.c        **** //      //is measurement is done, store and start next
  64:main.c        **** //      if(TIFR0 & (1<<ICF0)){
  65:main.c        **** //
  66:main.c        **** //          //calculate duration
  67:main.c        **** //          cur_meas = ((uint16_t)ICR0) - cur_meas;
  68:main.c        **** //
  69:main.c        **** //          //----------------------------
  70:main.c        **** //          //critical section (keep short)
  71:main.c        **** //          cli(); //disable interrupts
  72:main.c        **** //          //store timer value
  73:main.c        **** //          cur_meas = TCNT0;
  74:main.c        **** //          //set output pin
  75:main.c        **** //
  76:main.c        **** //          sei(); //enable interrupts
  77:main.c        **** //          //----------------------------
  78:main.c        **** //
  79:main.c        **** //      }
  80:main.c        **** 
  81:main.c        **** 
  82:main.c        **** 
  83:main.c        **** 
  84:main.c        ****   }
  85:main.c        **** 
  86:main.c        ****   return 0;
  87:main.c        **** }
  88:main.c        **** 
  89:main.c        **** 
  90:main.c        **** void init(void){
  18               		.loc 1 90 0
  19               		.cfi_startproc
  20               	/* prologue: function */
  21               	/* frame size = 0 */
  22               	/* stack size = 0 */
  23               	.L__stack_usage = 0
  91:main.c        **** 
  92:main.c        ****     //set clock to 8Mhz, no prescaler, factory calibration
  93:main.c        ****     CLKMSR = 0x00;
  24               		.loc 1 93 0
  25 0000 17BF      		out 55-0,__zero_reg__
  94:main.c        ****     OSCCAL = 0x00;
  26               		.loc 1 94 0
  27 0002 19BF      		out 57-0,__zero_reg__
  95:main.c        ****     CLKPSR = 0x00;
  28               		.loc 1 95 0
  29 0004 16BF      		out 54-0,__zero_reg__
  96:main.c        **** 
  97:main.c        ****     //set timer to CTC mode, no output compare, no prescaler
  98:main.c        ****     //reset on OCROB = floor(65536 / OCR_INCREMENT) * OCR_INCREMEN
  99:main.c        ****     //interrupt on OVF and OCIE0A
 100:main.c        ****     TCCR0A = 0x00;
  30               		.loc 1 100 0
  31 0006 1EBD      		out 46-0,__zero_reg__
 101:main.c        ****     TCCR0B = 0x00; //leave timer disabled for now (1<<CS00);
  32               		.loc 1 101 0
  33 0008 1DBD      		out 45-0,__zero_reg__
 102:main.c        ****     TIMSK0 = (1<<TOIE0) | (1<<OCIE0A) | (1<<OCIE0B);
  34               		.loc 1 102 0
  35 000a 87E0      		ldi r24,lo8(7)
  36 000c 8BBD      		out 43-0,r24
  37               	/* epilogue start */
 103:main.c        ****     //set first compare value to 1/19200/2 = 26us = 208 tim-ticks @ 8MHz
 104:main.c        ****     //TODO: verify 16 bit access
 105:main.c        **** 
 106:main.c        **** 
 107:main.c        ****     //GPIO init
 108:main.c        ****     //set led and touch to output
 109:main.c        ****     //set one pin to output for uart
 110:main.c        ****     //the other to input with pullup for uart
 111:main.c        **** 
 112:main.c        **** 
 113:main.c        **** }
  38               		.loc 1 113 0
  39 000e 0895      		ret
  40               		.cfi_endproc
  41               	.LFE7:
  43               		.section	.text.startup,"ax",@progbits
  44               	.global	main
  46               	main:
  47               	.LFB6:
  38:main.c        **** int main(void) {
  48               		.loc 1 38 0
  49               		.cfi_startproc
  50               	/* prologue: function */
  51               	/* frame size = 0 */
  52               	/* stack size = 0 */
  53               	.L__stack_usage = 0
  40:main.c        ****   init();
  54               		.loc 1 40 0
  55 0000 00D0      		rcall init
  59:main.c        ****           EIMSK = (1 << INT0);
  56               		.loc 1 59 0
  57 0002 61E0      		ldi r22,lo8(1)
  58               	.L9:
  45:main.c        ****       if( ( EIMSK & (1 << INT0) ) && ( TIMSK0 & (1 << OCIE0A) ) )
  59               		.loc 1 45 0
  60 0004 989B      		sbis 19-0,0
  61 0006 00C0      		rjmp .L9
  45:main.c        ****       if( ( EIMSK & (1 << INT0) ) && ( TIMSK0 & (1 << OCIE0A) ) )
  62               		.loc 1 45 0 is_stmt 0 discriminator 1
  63 0008 0BB5      		in __tmp_reg__,43-0
  64 000a 01FF      		sbrs __tmp_reg__,1
  65 000c 00C0      		rjmp .L9
  49:main.c        ****           if(cur_rx & (1 << SLOT_TAKEN_BIT)){
  66               		.loc 1 49 0 is_stmt 1
  67 000e 90A0      		lds r25,cur_rx
  68 0010 97FF      		sbrs r25,7
  69 0012 00C0      		rjmp .L4
  51:main.c        ****               cur_conf = cur_rx;
  70               		.loc 1 51 0
  71 0014 90A8      		sts cur_conf,r25
  52:main.c        ****               cur_tx = cur_rx | (1<<SLOT_TAKEN_BIT) | cur_touch;
  72               		.loc 1 52 0
  73 0016 80A0      		lds r24,cur_touch
  74 0018 892B      		or r24,r25
  75 001a 8068      		ori r24,lo8(-128)
  76 001c 80A8      		sts cur_tx,r24
  77 001e 00C0      		rjmp .L5
  78               	.L4:
  55:main.c        ****               cur_tx = cur_rx;
  79               		.loc 1 55 0
  80 0020 90A8      		sts cur_tx,r25
  81               	.L5:
  59:main.c        ****           EIMSK = (1 << INT0);
  82               		.loc 1 59 0
  83 0022 63BB      		out 19-0,r22
  84 0024 00C0      		rjmp .L9
  85               		.cfi_endproc
  86               	.LFE6:
  88               		.text
  89               	.global	__vector_1
  91               	__vector_1:
  92               	.LFB8:
 114:main.c        **** 
 115:main.c        **** 
 116:main.c        **** 
 117:main.c        **** 
 118:main.c        **** 
 119:main.c        **** 
 120:main.c        **** //=====================================
 121:main.c        **** //INTERRUPT HANDLERS
 122:main.c        **** //=====================================
 123:main.c        **** 
 124:main.c        **** //Warning, interrupts are ISR_NAKED to reduce jitter in the start
 125:main.c        **** //of the cap measurement and UART sample times. Be careful when
 126:main.c        **** //changing
 127:main.c        **** 
 128:main.c        **** //external interrupt (start of UART RX)
 129:main.c        **** ISR(INT0_vect,ISR_NAKED){
  93               		.loc 1 129 0
  94               		.cfi_startproc
  95               	/* prologue: naked */
  96               	/* frame size = 0 */
  97               	/* stack size = 0 */
  98               	.L__stack_usage = 0
 130:main.c        **** 
 131:main.c        ****     //allow touch to interrupt
 132:main.c        ****     sei();
  99               		.loc 1 132 0
 100               	/* #APP */
 101               	 ;  132 "main.c" 1
 102 0010 7894      		sei
 103               	 ;  0 "" 2
 133:main.c        ****     //set first sample time
 134:main.c        ****     OCR0A = TCNT0+UART_HALF_OCR_INC;
 104               		.loc 1 134 0
 105               	/* #NOAPP */
 106 0012 88B5      		in r24,40-0
 107 0014 99B5      		in r25,40+1-0
 108 0016 8D56      		subi r24,lo8(-(403))
 109 0018 9E4F      		sbci r25,hi8(-(403))
 110 001a 97BD      		out 38+1-0,r25
 111 001c 86BD      		out 38-0,r24
 135:main.c        ****     //disable external interrupt, enable COMPA interrupt
 136:main.c        ****     EIMSK = 0x00;
 112               		.loc 1 136 0
 113 001e 13BB      		out 19-0,__zero_reg__
 137:main.c        ****     TIMSK0 |= (1<<OCIE0A);
 114               		.loc 1 137 0
 115 0020 8BB5      		in r24,43-0
 116 0022 8260      		ori r24,lo8(2)
 117 0024 8BBD      		out 43-0,r24
 118               	/* epilogue start */
 138:main.c        **** 
 139:main.c        **** }
 119               		.loc 1 139 0
 120               		.cfi_endproc
 121               	.LFE8:
 123               	.global	__vector_5
 125               	__vector_5:
 126               	.LFB9:
 140:main.c        **** 
 141:main.c        **** //OCR0A interrupt handler
 142:main.c        **** ISR(TIM0_COMPA_vect){
 127               		.loc 1 142 0
 128               		.cfi_startproc
 129 0026 1F93      		push r17
 130               	.LCFI0:
 131               		.cfi_def_cfa_offset 3
 132               		.cfi_offset 17, -2
 133 0028 0F93      		push r16
 134               	.LCFI1:
 135               		.cfi_def_cfa_offset 4
 136               		.cfi_offset 16, -3
 137 002a 0FB7      		in r16,__SREG__
 138 002c 0F93      		push r16
 139 002e 10E0      		ldi __zero_reg__,lo8(0)
 140 0030 6F93      		push r22
 141               	.LCFI2:
 142               		.cfi_def_cfa_offset 5
 143               		.cfi_offset 22, -4
 144 0032 7F93      		push r23
 145               	.LCFI3:
 146               		.cfi_def_cfa_offset 6
 147               		.cfi_offset 23, -5
 148 0034 8F93      		push r24
 149               	.LCFI4:
 150               		.cfi_def_cfa_offset 7
 151               		.cfi_offset 24, -6
 152 0036 9F93      		push r25
 153               	.LCFI5:
 154               		.cfi_def_cfa_offset 8
 155               		.cfi_offset 25, -7
 156               	/* prologue: Signal */
 157               	/* frame size = 0 */
 158               	/* stack size = 7 */
 159               	.L__stack_usage = 7
 143:main.c        **** 
 144:main.c        ****     //allow touch to interrupt
 145:main.c        ****     sei();
 160               		.loc 1 145 0
 161               	/* #APP */
 162               	 ;  145 "main.c" 1
 163 0038 7894      		sei
 164               	 ;  0 "" 2
 146:main.c        ****     //update OCR0A (always to reduce jitter)
 147:main.c        ****     OCR0A += UART_OCR_INC;
 165               		.loc 1 147 0
 166               	/* #NOAPP */
 167 003a 86B5      		in r24,38-0
 168 003c 97B5      		in r25,38+1-0
 169 003e 8E53      		subi r24,lo8(-(194))
 170 0040 9F4F      		sbci r25,hi8(-(194))
 171 0042 97BD      		out 38+1-0,r25
 172 0044 86BD      		out 38-0,r24
 148:main.c        **** 
 149:main.c        ****     //update RX and TX
 150:main.c        ****     if(tx_cnt == UART_START){
 173               		.loc 1 150 0
 174 0046 80A0      		lds r24,tx_cnt
 175 0048 8823      		tst r24
 176 004a 01F4      		brne .L12
 151:main.c        ****         //don't store sample, set TX low
 152:main.c        ****         PORTB &= ~(1 << UART_TX_PIN);
 177               		.loc 1 152 0
 178 004c 1198      		cbi 2-0,1
 153:main.c        ****         //icrement tx counter
 154:main.c        ****         tx_cnt++;
 179               		.loc 1 154 0
 180 004e 81E0      		ldi r24,lo8(1)
 181 0050 80A8      		sts tx_cnt,r24
 182 0052 00C0      		rjmp .L11
 183               	.L12:
 155:main.c        ****     } else if (tx_cnt < UART_STOP) {
 184               		.loc 1 155 0
 185 0054 8930      		cpi r24,lo8(9)
 186 0056 00F4      		brsh .L14
 156:main.c        ****         //store RX samle
 157:main.c        ****         cur_rx |= ((PINB >> 2) & 0x01);
 187               		.loc 1 157 0
 188 0058 80B1      		in r24,0-0
 189 005a 8695      		lsr r24
 190 005c 8695      		lsr r24
 191 005e 8170      		andi r24,lo8(1)
 192 0060 90A0      		lds r25,cur_rx
 193 0062 892B      		or r24,r25
 158:main.c        ****         cur_rx = (cur_rx << 1);
 194               		.loc 1 158 0
 195 0064 880F      		lsl r24
 196 0066 80A8      		sts cur_rx,r24
 159:main.c        ****         //set TX output
 160:main.c        ****         PORTB  = (PORTB & ~(1 << UART_TX_PIN)) | ((cur_tx & 0x01) << UART_TX_PIN);
 197               		.loc 1 160 0
 198 0068 62B1      		in r22,2-0
 199 006a 70A0      		lds r23,cur_tx
 200 006c 872F      		mov r24,r23
 201 006e 90E0      		ldi r25,lo8(0)
 202 0070 8170      		andi r24,lo8(1)
 203 0072 9070      		andi r25,hi8(1)
 204 0074 880F      		lsl r24
 205 0076 991F      		rol r25
 206 0078 6D7F      		andi r22,lo8(-3)
 207 007a 682B      		or r22,r24
 208 007c 62B9      		out 2-0,r22
 161:main.c        ****         cur_tx = (cur_tx >> 1);
 209               		.loc 1 161 0
 210 007e 7695      		lsr r23
 211 0080 70A8      		sts cur_tx,r23
 212 0082 00C0      		rjmp .L11
 213               	.L14:
 162:main.c        ****         //increment tx counter
 163:main.c        ****     } else {
 164:main.c        ****         //don't sample, set TX high
 165:main.c        ****         PORTB |= (1<<UART_TX_PIN);
 214               		.loc 1 165 0
 215 0084 119A      		sbi 2-0,1
 166:main.c        ****         //enable external interrupt, enable COMPA interrupt
 167:main.c        ****         //EIMSK = 0x01; TODO:think about sync with main
 168:main.c        ****         TIMSK0 &= ~(1<<OCIE0A);
 216               		.loc 1 168 0
 217 0086 8BB5      		in r24,43-0
 218 0088 8D7F      		andi r24,lo8(-3)
 219 008a 8BBD      		out 43-0,r24
 169:main.c        ****         //we are done, set tx_counter to 0
 170:main.c        ****         tx_cnt = 0x00;
 220               		.loc 1 170 0
 221 008c 10A8      		sts tx_cnt,__zero_reg__
 222               	.L11:
 223               	/* epilogue start */
 171:main.c        ****     }
 172:main.c        **** 
 173:main.c        **** }
 224               		.loc 1 173 0
 225 008e 9F91      		pop r25
 226 0090 8F91      		pop r24
 227 0092 7F91      		pop r23
 228 0094 6F91      		pop r22
 229 0096 0F91      		pop r16
 230 0098 0FBF      		out __SREG__,r16
 231 009a 0F91      		pop r16
 232 009c 1F91      		pop r17
 233 009e 1895      		reti
 234               		.cfi_endproc
 235               	.LFE9:
 237               	.global	__vector_4
 239               	__vector_4:
 240               	.LFB10:
 174:main.c        **** 
 175:main.c        **** 
 176:main.c        **** //TIM0 overflow handler,
 177:main.c        **** //Start touch measurement by setting pin to input
 178:main.c        **** ISR(TIM0_OVF_vect, ISR_NAKED){
 241               		.loc 1 178 0
 242               		.cfi_startproc
 243               	/* prologue: naked */
 244               	/* frame size = 0 */
 245               	/* stack size = 0 */
 246               	.L__stack_usage = 0
 179:main.c        ****     //set cap_touch pin to input pin to input
 180:main.c        ****     //DDRB = (1 << CAP_TOUCH_PIN);
 181:main.c        ****     asm("push r24");
 247               		.loc 1 181 0
 248               	/* #APP */
 249               	 ;  181 "main.c" 1
 250 00a0 8F93      		push r24
 251               	 ;  0 "" 2
 182:main.c        ****     asm("ldi r24,lo8(2)");
 252               		.loc 1 182 0
 253               	 ;  182 "main.c" 1
 254 00a2 82E0      		ldi r24,lo8(2)
 255               	 ;  0 "" 2
 183:main.c        ****     asm("out 1,r24");
 256               		.loc 1 183 0
 257               	 ;  183 "main.c" 1
 258 00a4 81B9      		out 1,r24
 259               	 ;  0 "" 2
 184:main.c        ****     asm("pop r24");
 260               		.loc 1 184 0
 261               	 ;  184 "main.c" 1
 262 00a6 8F91      		pop r24
 263               	 ;  0 "" 2
 185:main.c        ****     asm("reti");
 264               		.loc 1 185 0
 265               	 ;  185 "main.c" 1
 266 00a8 1895      		reti
 267               	 ;  0 "" 2
 268               	/* epilogue start */
 186:main.c        **** }
 269               		.loc 1 186 0
 270               	/* #NOAPP */
 271               		.cfi_endproc
 272               	.LFE10:
 274               	.global	__vector_6
 276               	__vector_6:
 277               	.LFB11:
 187:main.c        **** 
 188:main.c        **** 
 189:main.c        **** //TIM0 OCR0B match handler
 190:main.c        **** //Disable timer interrupts for touch, until main has processed
 191:main.c        **** //measurement
 192:main.c        **** ISR(TIM0_COMPB_vect,ISR_NAKED){
 278               		.loc 1 192 0
 279               		.cfi_startproc
 280               	/* prologue: naked */
 281               	/* frame size = 0 */
 282               	/* stack size = 0 */
 283               	.L__stack_usage = 0
 193:main.c        ****     //only enable OCR0A interrupt
 194:main.c        ****     //TIMSK0 &= (1<<OCIE0A);
 195:main.c        ****     asm("push r24");
 284               		.loc 1 195 0
 285               	/* #APP */
 286               	 ;  195 "main.c" 1
 287 00aa 8F93      		push r24
 288               	 ;  0 "" 2
 196:main.c        ****     asm("in r24,43");
 289               		.loc 1 196 0
 290               	 ;  196 "main.c" 1
 291 00ac 8BB5      		in r24,43
 292               	 ;  0 "" 2
 197:main.c        ****     asm("andi r24,lo8(2)");
 293               		.loc 1 197 0
 294               	 ;  197 "main.c" 1
 295 00ae 8270      		andi r24,lo8(2)
 296               	 ;  0 "" 2
 198:main.c        ****     asm("out 43,r24");
 297               		.loc 1 198 0
 298               	 ;  198 "main.c" 1
 299 00b0 8BBD      		out 43,r24
 300               	 ;  0 "" 2
 199:main.c        ****     asm("pop r24");
 301               		.loc 1 199 0
 302               	 ;  199 "main.c" 1
 303 00b2 8F91      		pop r24
 304               	 ;  0 "" 2
 200:main.c        ****     asm("reti");
 305               		.loc 1 200 0
 306               	 ;  200 "main.c" 1
 307 00b4 1895      		reti
 308               	 ;  0 "" 2
 309               	/* epilogue start */
 201:main.c        **** }
 310               		.loc 1 201 0
 311               	/* #NOAPP */
 312               		.cfi_endproc
 313               	.LFE11:
 315               		.comm tx_cnt,1,1
 316               		.comm cur_tx,1,1
 317               		.comm cur_rx,1,1
 318               		.comm cur_touch,1,1
 319               		.comm cur_conf,1,1
 320               		.comm cur_meas,2,1
 321               	.Letext0:
 322               		.file 2 "/opt/cross/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccElG7WH.s:2      *ABS*:000000000000003f __SREG__
     /tmp/ccElG7WH.s:3      *ABS*:000000000000003e __SP_H__
     /tmp/ccElG7WH.s:4      *ABS*:000000000000003d __SP_L__
     /tmp/ccElG7WH.s:5      *ABS*:000000000000003c __CCP__
     /tmp/ccElG7WH.s:6      *ABS*:0000000000000010 __tmp_reg__
     /tmp/ccElG7WH.s:7      *ABS*:0000000000000011 __zero_reg__
     /tmp/ccElG7WH.s:15     .text:0000000000000000 init
     /tmp/ccElG7WH.s:46     .text.startup:0000000000000000 main
                            *COM*:0000000000000001 cur_rx
                            *COM*:0000000000000001 cur_conf
                            *COM*:0000000000000001 cur_touch
                            *COM*:0000000000000001 cur_tx
     /tmp/ccElG7WH.s:91     .text:0000000000000010 __vector_1
     /tmp/ccElG7WH.s:125    .text:0000000000000026 __vector_5
                            *COM*:0000000000000001 tx_cnt
     /tmp/ccElG7WH.s:239    .text:00000000000000a0 __vector_4
     /tmp/ccElG7WH.s:276    .text:00000000000000aa __vector_6
                            *COM*:0000000000000002 cur_meas

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
