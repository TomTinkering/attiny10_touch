   1               		.file	"main.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x3c
   6               	__tmp_reg__ = 16
   7               	__zero_reg__ = 17
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  10               		.text
  11               	.Ltext0:
  12               		.cfi_sections	.debug_frame
  13               	.global	init
  15               	init:
  16               	.LFB7:
  17               		.file 1 "main.c"
   1:main.c        **** #include <util/delay.h>
   2:main.c        **** #include <avr/io.h>
   3:main.c        **** #include <avr/interrupt.h>
   4:main.c        **** 
   5:main.c        **** #define TRUE (1)
   6:main.c        **** #define FALSE (0)
   7:main.c        **** 
   8:main.c        **** 
   9:main.c        **** 
  10:main.c        **** 
  11:main.c        **** void init(void);
  12:main.c        **** 
  13:main.c        **** 
  14:main.c        **** 
  15:main.c        **** typedef enum state_t {
  16:main.c        **** 
  17:main.c        ****     TAKEN_PASSED    = 0,
  18:main.c        ****     LED_EN          = 1,
  19:main.c        ****     SET_LED_DIRECT  = 2,
  20:main.c        ****     TOUCHED         = 3,
  21:main.c        ****     RESERVED        = 4,
  22:main.c        ****     LED0            = 5,
  23:main.c        ****     LED1            = 6,
  24:main.c        ****     LED2            = 7
  25:main.c        **** 
  26:main.c        **** } state_t;
  27:main.c        **** 
  28:main.c        **** typedef enum msg_t {
  29:main.c        **** 
  30:main.c        ****     MSG_SLOT_TAKEN  = 0,
  31:main.c        ****     MSG_LED_EN      = 1,
  32:main.c        ****     MSG_LED_DIRECT  = 2,
  33:main.c        ****     MSG_IS_TOUCHED  = 3,
  34:main.c        ****     MSG_RESERVED    = 4,
  35:main.c        ****     MSG_LED0        = 5,
  36:main.c        ****     MSG_LED1        = 6,
  37:main.c        ****     MSG_LED2        = 7
  38:main.c        **** 
  39:main.c        **** } msg_t;
  40:main.c        **** 
  41:main.c        **** 
  42:main.c        **** #define DEFAULT_CONFIGURATION (0b10101010) //TODO: change to proper setting
  43:main.c        **** #define WRITE_PROTECT_DISABLE_SIG (0xD8)
  44:main.c        **** 
  45:main.c        **** #define TOUCH_TIMEOUT ((uint16_t)40000) //roughly 4ms @ 8MHz
  46:main.c        **** #define TOUCH_PIN (PIN1) //TODO: set proper pin (change interrupt)
  47:main.c        **** #define LED_PIN   (PIN0)
  48:main.c        **** 
  49:main.c        **** //the number of instructions before INT0 is executed
  50:main.c        **** #define ISR_OFFSET     (4+10) //4 till call, 10 till instruction
  51:main.c        **** 
  52:main.c        **** //next sample instant 1/19200 = 52us =~ 417 tim-ticks @ 8MHz
  53:main.c        **** #define UART_BIT_TIME       ((uint16_t)417) //number of clock ticks @8MHz per bit
  54:main.c        **** 
  55:main.c        **** #define UART_OCR_OFFSET     (4+10) //4 till call, 10 till instruction
  56:main.c        **** #define UART_OCR_INC        ((UART_BIT_TIME / 2)-UART_OCR_OFFSET)
  57:main.c        **** #define UART_HALF_OCR_INC   (UART_BIT_TIME-UART_OCR_OFFSET)
  58:main.c        **** 
  59:main.c        **** #define UART_RX_PIN    (PB2)
  60:main.c        **** #define UART_TX_PIN    (PB3)
  61:main.c        **** #define UART_START     (0)
  62:main.c        **** #define UART_STOP      (9)
  63:main.c        **** 
  64:main.c        **** //protocol definitions
  65:main.c        **** #define SLOT_TAKEN_BIT (7)
  66:main.c        **** 
  67:main.c        **** 
  68:main.c        **** //some macro's to avoid stupid mistakes...
  69:main.c        **** #define IS_SET(var,b)   (var & (1 << b))
  70:main.c        **** #define IS_NSET(var,b)   !(var & (1 << b))
  71:main.c        **** #define SET(var,b)      (var |= (1 << b))
  72:main.c        **** #define CLR(var,b)      (var &= ~(1 << b))
  73:main.c        **** #define B(b)            (1 << b)
  74:main.c        **** 
  75:main.c        **** 
  76:main.c        **** //mask that determina what bits not to cpoy from rx msg
  77:main.c        **** #define CONF_BIT_MASK (B(MSG_SLOT_TAKEN) | B(MSG_RESERVED) | B(MSG_IS_TOUCHED))
  78:main.c        **** #define CONF_LED_MASK (B(LED0) | B(LED1) | B(LED2))
  79:main.c        **** 
  80:main.c        **** 
  81:main.c        **** //multiplier to avoid floating point...
  82:main.c        **** #define FILTER_MAX (1024)
  83:main.c        **** //portion of multiplier that is given to new value (USE POWER OF 2!!)
  84:main.c        **** #define FILTER_NEW (32)
  85:main.c        **** //portion of multiplier that is given to running average
  86:main.c        **** #define FILTER_AVG (FILTER_MAX-FILTER_NEW)
  87:main.c        **** //low pass filter, use sparingly, costly instruction wise
  88:main.c        **** #define TOUCH_FILTER_LP(avg,new) ((uint16_t)(( (((uint32_t)avg)*FILTER_AVG) + (((uint32_t)new)*FILT
  89:main.c        **** 
  90:main.c        **** 
  91:main.c        **** //level above measurement noise level to detect touch
  92:main.c        **** #define TOUCH_THRESHOLD (512)
  93:main.c        **** //number of measurements in a row, that are above threshold needed to trigger touch
  94:main.c        **** #define TOUCH_VALID_CNT (2)
  95:main.c        **** 
  96:main.c        **** 
  97:main.c        **** uint16_t    cur_meas;
  98:main.c        **** uint8_t     cur_conf,cur_touch;
  99:main.c        **** uint8_t     cur_rx,cur_tx,tx_cnt;
 100:main.c        **** uint8_t     state;
 101:main.c        **** uint8_t     led_val;
 102:main.c        **** 
 103:main.c        **** uint8_t     touch_cnt;
 104:main.c        **** uint16_t    touch_new;
 105:main.c        **** uint16_t    touch_avg; //use sparsely on 8-bit machine...
 106:main.c        **** 
 107:main.c        **** 
 108:main.c        **** 
 109:main.c        **** int main(void) {
 110:main.c        **** 
 111:main.c        ****   init();
 112:main.c        **** 
 113:main.c        ****   while(TRUE){
 114:main.c        **** 
 115:main.c        ****       //if uart cycle has completed (both interrupts disabled) prepare next
 116:main.c        ****       if( IS_NSET(EIMSK,INT0) && IS_NSET(TIMSK0,OCIE0B) )
 117:main.c        ****       {
 118:main.c        **** 
 119:main.c        **** 
 120:main.c        ****       //uart is only processed at end of each byte, leave all the other time for
 121:main.c        ****       //processing measurements (this possibly allows higher UART speeds)
 122:main.c        ****       } else {
 123:main.c        **** 
 124:main.c        **** 
 125:main.c        **** 
 126:main.c        ****           //check for touch timeout / process measurement
 127:main.c        ****           if( (TCNT0 >= TOUCH_TIMEOUT)  ) {
 128:main.c        **** 
 129:main.c        ****               //get input capture time, or limit if no capture occured
 130:main.c        ****               touch_new=(IS_SET(TIFR0,ICF0)) ? ICR0 : TOUCH_TIMEOUT;
 131:main.c        ****               //determine new running average
 132:main.c        ****               touch_avg = TOUCH_FILTER_LP(touch_avg,touch_new);
 133:main.c        ****               //compare new measurement to running average
 134:main.c        ****               if(touch_new > (touch_avg + TOUCH_THRESHOLD)){
 135:main.c        ****                   touch_cnt++;
 136:main.c        ****                   if(touch_cnt >= TOUCH_VALID_CNT){
 137:main.c        ****                       touch_cnt = TOUCH_VALID_CNT; //need for prolonged touch > 1s (avoid overflow)
 138:main.c        ****                       SET(state,TOUCHED);
 139:main.c        ****                   }
 140:main.c        ****               } else {
 141:main.c        ****                   touch_cnt = 0;
 142:main.c        ****               }
 143:main.c        **** 
 144:main.c        ****               //start new measurement (clear ICF0, set pin to LOW)
 145:main.c        ****               SET(TIFR0,ICF0);
 146:main.c        ****               CLR(PORTB,TOUCH_PIN);
 147:main.c        ****               SET(DDRB,TOUCH_PIN);
 148:main.c        ****           }
 149:main.c        **** 
 150:main.c        ****           //enable or disable led based on system state
 151:main.c        ****           if( IS_SET(state,LED_EN) || (IS_SET(state,SET_LED_DIRECT) && IS_SET(state,TOUCHED)) ){
 152:main.c        ****               //set led pin to output
 153:main.c        ****               SET(DDRB,LED_PIN);
 154:main.c        ****               CLR(PUEB,LED_PIN);
 155:main.c        ****           } else { //turn off led
 156:main.c        ****               //just setting pin to input is enough
 157:main.c        ****               CLR(DDRB,LED_PIN);
 158:main.c        ****               SET(PUEB,LED_PIN);
 159:main.c        ****           }
 160:main.c        **** 
 161:main.c        ****       }
 162:main.c        **** 
 163:main.c        ****   }
 164:main.c        **** 
 165:main.c        ****   //should not reach
 166:main.c        ****   return 0;
 167:main.c        **** }
 168:main.c        **** 
 169:main.c        **** 
 170:main.c        **** void init(void){
  18               		.loc 1 170 0
  19               		.cfi_startproc
  20               	/* prologue: function */
  21               	/* frame size = 0 */
  22               	/* stack size = 0 */
  23               	.L__stack_usage = 0
 171:main.c        **** 
 172:main.c        ****     cli(); //disable interrupts for the time being
  24               		.loc 1 172 0
  25               	/* #APP */
  26               	 ;  172 "main.c" 1
  27 0000 F894      		cli
  28               	 ;  0 "" 2
 173:main.c        **** 
 174:main.c        ****     //set clock to 8Mhz, no prescaler, factory calibration
 175:main.c        ****     CCP = WRITE_PROTECT_DISABLE_SIG;
  29               		.loc 1 175 0
  30               	/* #NOAPP */
  31 0002 88ED      		ldi r24,lo8(-40)
  32 0004 8CBF      		out 60-0,r24
 176:main.c        ****     CLKPSR = 0x00;
  33               		.loc 1 176 0
  34 0006 16BF      		out 54-0,__zero_reg__
 177:main.c        ****     CLKMSR = 0x00;
  35               		.loc 1 177 0
  36 0008 17BF      		out 55-0,__zero_reg__
 178:main.c        **** 
 179:main.c        ****     //GPIO init
 180:main.c        ****     PORTB = B(LED_PIN) | B(UART_TX_PIN);
  37               		.loc 1 180 0
  38 000a 89E0      		ldi r24,lo8(9)
  39 000c 82B9      		out 2-0,r24
 181:main.c        ****     DDRB  = B(LED_PIN) | B(TOUCH_PIN) | B(UART_TX_PIN);
  40               		.loc 1 181 0
  41 000e 8BE0      		ldi r24,lo8(11)
  42 0010 81B9      		out 1-0,r24
 182:main.c        ****     PUEB  = B(UART_RX_PIN);
  43               		.loc 1 182 0
  44 0012 84E0      		ldi r24,lo8(4)
  45 0014 83B9      		out 3-0,r24
 183:main.c        **** 
 184:main.c        ****     //set timer normal mode (0xFFFF top is convenient for UART)
 185:main.c        ****     //disconnect output compare functionality
 186:main.c        ****     //enable input capture noise filter, trigger on rising edge ( 0->1)
 187:main.c        ****     //leave timer disabled for now (no clock source)
 188:main.c        ****     TCCR0A = 0x00;
  46               		.loc 1 188 0
  47 0016 1EBD      		out 46-0,__zero_reg__
 189:main.c        ****     TCCR0B = B(ICNC0) | B(ICES0);
  48               		.loc 1 189 0
  49 0018 80EC      		ldi r24,lo8(-64)
  50 001a 8DBD      		out 45-0,r24
 190:main.c        ****     //disable interrupts and clear timer for now
 191:main.c        ****     TIMSK0 = 0x00;
  51               		.loc 1 191 0
  52 001c 1BBD      		out 43-0,__zero_reg__
 192:main.c        ****     TCNT0  = 0x0000;
  53               		.loc 1 192 0
  54 001e 19BD      		out 40+1-0,__zero_reg__
  55 0020 18BD      		out 40-0,__zero_reg__
 193:main.c        **** 
 194:main.c        ****     //TODO: RSTDISBL bit ...fuse
 195:main.c        **** 
 196:main.c        ****     //since all interrupts are disabled, cur_rx will be read as first config
 197:main.c        ****     cur_rx = DEFAULT_CONFIGURATION;
  56               		.loc 1 197 0
  57 0022 8AEA      		ldi r24,lo8(-86)
  58 0024 80A8      		sts cur_rx,r24
 198:main.c        ****     //enable ovf interrupt, start the timer and let the magic begin
 199:main.c        ****     SET(TIMSK0,TOIE0);
  59               		.loc 1 199 0
  60 0026 8BB5      		in r24,43-0
  61 0028 8160      		ori r24,lo8(1)
  62 002a 8BBD      		out 43-0,r24
 200:main.c        ****     SET(TCCR0B,CS00);
  63               		.loc 1 200 0
  64 002c 8DB5      		in r24,45-0
  65 002e 8160      		ori r24,lo8(1)
  66 0030 8DBD      		out 45-0,r24
 201:main.c        ****     sei();
  67               		.loc 1 201 0
  68               	/* #APP */
  69               	 ;  201 "main.c" 1
  70 0032 7894      		sei
  71               	 ;  0 "" 2
  72               	/* epilogue start */
 202:main.c        **** 
 203:main.c        **** }
  73               		.loc 1 203 0
  74               	/* #NOAPP */
  75 0034 0895      		ret
  76               		.cfi_endproc
  77               	.LFE7:
  79               		.section	.text.startup,"ax",@progbits
  80               	.global	main
  82               	main:
  83               	.LFB6:
 109:main.c        **** int main(void) {
  84               		.loc 1 109 0
  85               		.cfi_startproc
  86 0000 CF93      		push r28
  87               	.LCFI0:
  88               		.cfi_def_cfa_offset 3
  89               		.cfi_offset 28, -2
  90 0002 DF93      		push r29
  91               	.LCFI1:
  92               		.cfi_def_cfa_offset 4
  93               		.cfi_offset 29, -3
  94 0004 00D0      		rcall .
  95 0006 00D0      		rcall .
  96               	.LCFI2:
  97               		.cfi_def_cfa_offset 8
  98 0008 CDB7      		in r28,__SP_L__
  99 000a DEB7      		in r29,__SP_H__
 100               	.LCFI3:
 101               		.cfi_def_cfa_register 28
 102               	/* prologue: function */
 103               	/* frame size = 4 */
 104               	/* stack size = 6 */
 105               	.L__stack_usage = 6
 111:main.c        ****   init();
 106               		.loc 1 111 0
 107 000c 00D0      		rcall init
 137:main.c        ****                       touch_cnt = TOUCH_VALID_CNT; //need for prolonged touch > 1s (avoid overflow)
 108               		.loc 1 137 0
 109 000e E2E0      		ldi r30,lo8(2)
 110               	.L15:
 116:main.c        ****       if( IS_NSET(EIMSK,INT0) && IS_NSET(TIMSK0,OCIE0B) )
 111               		.loc 1 116 0
 112 0010 9899      		sbic 19-0,0
 113 0012 00C0      		rjmp .L4
 116:main.c        ****       if( IS_NSET(EIMSK,INT0) && IS_NSET(TIMSK0,OCIE0B) )
 114               		.loc 1 116 0 is_stmt 0 discriminator 1
 115 0014 0BB5      		in __tmp_reg__,43-0
 116 0016 02FF      		sbrs __tmp_reg__,2
 117 0018 00C0      		rjmp .L15
 118               	.L4:
 127:main.c        ****           if( (TCNT0 >= TOUCH_TIMEOUT)  ) {
 119               		.loc 1 127 0 is_stmt 1
 120 001a 88B5      		in r24,40-0
 121 001c 99B5      		in r25,40+1-0
 122 001e 4CE9      		ldi r20,hi8(-25536)
 123 0020 8034      		cpi r24,lo8(-25536)
 124 0022 9407      		cpc r25,r20
 125 0024 00F4      		brsh .+2
 126 0026 00C0      		rjmp .L6
 130:main.c        ****               touch_new=(IS_SET(TIFR0,ICF0)) ? ICR0 : TOUCH_TIMEOUT;
 127               		.loc 1 130 0
 128 0028 0AB5      		in __tmp_reg__,42-0
 129 002a 05FF      		sbrs __tmp_reg__,5
 130 002c 00C0      		rjmp .L12
 130:main.c        ****               touch_new=(IS_SET(TIFR0,ICF0)) ? ICR0 : TOUCH_TIMEOUT;
 131               		.loc 1 130 0 is_stmt 0 discriminator 1
 132 002e 22B5      		in r18,34-0
 133 0030 33B5      		in r19,34+1-0
 134 0032 00C0      		rjmp .L7
 135               	.L12:
 130:main.c        ****               touch_new=(IS_SET(TIFR0,ICF0)) ? ICR0 : TOUCH_TIMEOUT;
 136               		.loc 1 130 0
 137 0034 20E4      		ldi r18,lo8(-25536)
 138 0036 3CE9      		ldi r19,hi8(-25536)
 139               	.L7:
 130:main.c        ****               touch_new=(IS_SET(TIFR0,ICF0)) ? ICR0 : TOUCH_TIMEOUT;
 140               		.loc 1 130 0 discriminator 3
 141 0038 30A8      		sts touch_new+1,r19
 142 003a 20A8      		sts touch_new,r18
 132:main.c        ****               touch_avg = TOUCH_FILTER_LP(touch_avg,touch_new);
 143               		.loc 1 132 0 is_stmt 1 discriminator 3
 144 003c 622F      		mov r22,r18
 145 003e 732F      		mov r23,r19
 146 0040 80E0      		ldi r24,lo8(0)
 147 0042 90E0      		ldi r25,hi8(0)
 148 0044 CF5F      		subi r28,lo8(-(1))
 149 0046 DF4F      		sbci r29,hi8(-(1))
 150 0048 6993      		st Y+,r22
 151 004a 7993      		st Y+,r23
 152 004c 8993      		st Y+,r24
 153 004e 9883      		st Y,r25
 154 0050 C450      		subi r28,lo8(1+3)
 155 0052 D040      		sbci r29,hi8(1+3)
 156 0054 40A0      		lds r20,touch_avg
 157 0056 50A0      		lds r21,touch_avg+1
 158 0058 60E0      		ldi r22,lo8(0)
 159 005a 70E0      		ldi r23,hi8(0)
 160 005c B72F      		mov r27,r23
 161 005e A62F      		mov r26,r22
 162 0060 952F      		mov r25,r21
 163 0062 842F      		mov r24,r20
 164 0064 F5E0      		ldi r31,5
 165 0066 880F      	1:	lsl r24
 166 0068 991F      		rol r25
 167 006a AA1F      		rol r26
 168 006c BB1F      		rol r27
 169 006e FA95      		dec r31
 170 0070 01F4      		brne 1b
 171 0072 841B      		sub r24,r20
 172 0074 950B      		sbc r25,r21
 173 0076 A60B      		sbc r26,r22
 174 0078 B70B      		sbc r27,r23
 175 007a CF5F      		subi r28,lo8(-(1))
 176 007c DF4F      		sbci r29,hi8(-(1))
 177 007e 4991      		ld r20,Y+
 178 0080 5991      		ld r21,Y+
 179 0082 6991      		ld r22,Y+
 180 0084 7881      		ld r23,Y
 181 0086 C450      		subi r28,lo8(1+3)
 182 0088 D040      		sbci r29,hi8(1+3)
 183 008a 480F      		add r20,r24
 184 008c 591F      		adc r21,r25
 185 008e 6A1F      		adc r22,r26
 186 0090 7B1F      		adc r23,r27
 187 0092 F5E0      		ldi r31,5
 188 0094 440F      	1:	lsl r20
 189 0096 551F      		rol r21
 190 0098 661F      		rol r22
 191 009a 771F      		rol r23
 192 009c FA95      		dec r31
 193 009e 01F4      		brne 1b
 194 00a0 FAE0      		ldi r31,10
 195 00a2 7695      	1:	lsr r23
 196 00a4 6795      		ror r22
 197 00a6 5795      		ror r21
 198 00a8 4795      		ror r20
 199 00aa FA95      		dec r31
 200 00ac 01F4      		brne 1b
 201 00ae CF5F      		subi r28,lo8(-(1))
 202 00b0 DF4F      		sbci r29,hi8(-(1))
 203 00b2 4993      		st Y+,r20
 204 00b4 5993      		st Y+,r21
 205 00b6 6993      		st Y+,r22
 206 00b8 7883      		st Y,r23
 207 00ba C450      		subi r28,lo8(1+3)
 208 00bc D040      		sbci r29,hi8(1+3)
 209 00be 50A8      		sts touch_avg+1,r21
 210 00c0 40A8      		sts touch_avg,r20
 134:main.c        ****               if(touch_new > (touch_avg + TOUCH_THRESHOLD)){
 211               		.loc 1 134 0 discriminator 3
 212 00c2 CF5F      		subi r28,lo8(-(1))
 213 00c4 DF4F      		sbci r29,hi8(-(1))
 214 00c6 8991      		ld r24,Y+
 215 00c8 9881      		ld r25,Y
 216 00ca C250      		subi r28,lo8(1+1)
 217 00cc D040      		sbci r29,hi8(1+1)
 218 00ce 8050      		subi r24,lo8(-(512))
 219 00d0 9E4F      		sbci r25,hi8(-(512))
 220 00d2 8217      		cp r24,r18
 221 00d4 9307      		cpc r25,r19
 222 00d6 00F4      		brsh .L8
 135:main.c        ****                   touch_cnt++;
 223               		.loc 1 135 0
 224 00d8 80A0      		lds r24,touch_cnt
 225 00da 8F5F      		subi r24,lo8(-(1))
 226 00dc 80A8      		sts touch_cnt,r24
 136:main.c        ****                   if(touch_cnt >= TOUCH_VALID_CNT){
 227               		.loc 1 136 0
 228 00de 8230      		cpi r24,lo8(2)
 229 00e0 00F0      		brlo .L9
 137:main.c        ****                       touch_cnt = TOUCH_VALID_CNT; //need for prolonged touch > 1s (avoid overflow)
 230               		.loc 1 137 0
 231 00e2 E0A8      		sts touch_cnt,r30
 138:main.c        ****                       SET(state,TOUCHED);
 232               		.loc 1 138 0
 233 00e4 80A0      		lds r24,state
 234 00e6 8860      		ori r24,lo8(8)
 235 00e8 80A8      		sts state,r24
 236 00ea 00C0      		rjmp .L9
 237               	.L8:
 141:main.c        ****                   touch_cnt = 0;
 238               		.loc 1 141 0
 239 00ec 10A8      		sts touch_cnt,__zero_reg__
 240               	.L9:
 145:main.c        ****               SET(TIFR0,ICF0);
 241               		.loc 1 145 0
 242 00ee 8AB5      		in r24,42-0
 243 00f0 8062      		ori r24,lo8(32)
 244 00f2 8ABD      		out 42-0,r24
 146:main.c        ****               CLR(PORTB,TOUCH_PIN);
 245               		.loc 1 146 0
 246 00f4 1198      		cbi 2-0,1
 147:main.c        ****               SET(DDRB,TOUCH_PIN);
 247               		.loc 1 147 0
 248 00f6 099A      		sbi 1-0,1
 249               	.L6:
 151:main.c        ****           if( IS_SET(state,LED_EN) || (IS_SET(state,SET_LED_DIRECT) && IS_SET(state,TOUCHED)) ){
 250               		.loc 1 151 0
 251 00f8 80A0      		lds r24,state
 252 00fa 90E0      		ldi r25,lo8(0)
 253 00fc 81FD      		sbrc r24,1
 254 00fe 00C0      		rjmp .L10
 109:main.c        **** int main(void) {
 255               		.loc 1 109 0 discriminator 1
 256 0100 8C70      		andi r24,lo8(12)
 257 0102 9070      		andi r25,hi8(12)
 151:main.c        ****           if( IS_SET(state,LED_EN) || (IS_SET(state,SET_LED_DIRECT) && IS_SET(state,TOUCHED)) ){
 258               		.loc 1 151 0 discriminator 1
 259 0104 8C30      		cpi r24,12
 260 0106 9107      		cpc r25,__zero_reg__
 261 0108 01F4      		brne .L11
 262               	.L10:
 153:main.c        ****               SET(DDRB,LED_PIN);
 263               		.loc 1 153 0
 264 010a 089A      		sbi 1-0,0
 154:main.c        ****               CLR(PUEB,LED_PIN);
 265               		.loc 1 154 0
 266 010c 1898      		cbi 3-0,0
 267 010e 00C0      		rjmp .L15
 268               	.L11:
 157:main.c        ****               CLR(DDRB,LED_PIN);
 269               		.loc 1 157 0
 270 0110 0898      		cbi 1-0,0
 158:main.c        ****               SET(PUEB,LED_PIN);
 271               		.loc 1 158 0
 272 0112 189A      		sbi 3-0,0
 273 0114 00C0      		rjmp .L15
 274               		.cfi_endproc
 275               	.LFE6:
 277               		.text
 278               	.global	__vector_1
 280               	__vector_1:
 281               	.LFB8:
 204:main.c        **** 
 205:main.c        **** 
 206:main.c        **** 
 207:main.c        **** 
 208:main.c        **** 
 209:main.c        **** 
 210:main.c        **** //=====================================
 211:main.c        **** //INTERRUPT HANDLERS
 212:main.c        **** //=====================================
 213:main.c        **** 
 214:main.c        **** //external interrupt (start of UART RX)
 215:main.c        **** ISR(INT0_vect){
 282               		.loc 1 215 0
 283               		.cfi_startproc
 284 0036 1F93      		push r17
 285               	.LCFI4:
 286               		.cfi_def_cfa_offset 3
 287               		.cfi_offset 17, -2
 288 0038 0F93      		push r16
 289               	.LCFI5:
 290               		.cfi_def_cfa_offset 4
 291               		.cfi_offset 16, -3
 292 003a 0FB7      		in r16,__SREG__
 293 003c 0F93      		push r16
 294 003e 10E0      		ldi __zero_reg__,lo8(0)
 295 0040 8F93      		push r24
 296               	.LCFI6:
 297               		.cfi_def_cfa_offset 5
 298               		.cfi_offset 24, -4
 299 0042 9F93      		push r25
 300               	.LCFI7:
 301               		.cfi_def_cfa_offset 6
 302               		.cfi_offset 25, -5
 303               	/* prologue: Signal */
 304               	/* frame size = 0 */
 305               	/* stack size = 5 */
 306               	.L__stack_usage = 5
 216:main.c        **** 
 217:main.c        ****     //allow touch to interrupt
 218:main.c        ****     sei();
 307               		.loc 1 218 0
 308               	/* #APP */
 309               	 ;  218 "main.c" 1
 310 0044 7894      		sei
 311               	 ;  0 "" 2
 219:main.c        **** 
 220:main.c        ****     //set first sample time
 221:main.c        ****     OCR0A = TCNT0+UART_HALF_OCR_INC;
 312               		.loc 1 221 0
 313               	/* #NOAPP */
 314 0046 88B5      		in r24,40-0
 315 0048 99B5      		in r25,40+1-0
 316 004a 8D56      		subi r24,lo8(-(403))
 317 004c 9E4F      		sbci r25,hi8(-(403))
 318 004e 97BD      		out 38+1-0,r25
 319 0050 86BD      		out 38-0,r24
 222:main.c        ****     //disable external interrupt, enable COMPA interrupt
 223:main.c        ****     EIMSK = 0x00;
 320               		.loc 1 223 0
 321 0052 13BB      		out 19-0,__zero_reg__
 224:main.c        ****     SET(TIMSK0,OCIE0B);
 322               		.loc 1 224 0
 323 0054 8BB5      		in r24,43-0
 324 0056 8460      		ori r24,lo8(4)
 325 0058 8BBD      		out 43-0,r24
 326               	/* epilogue start */
 225:main.c        **** 
 226:main.c        **** }
 327               		.loc 1 226 0
 328 005a 9F91      		pop r25
 329 005c 8F91      		pop r24
 330 005e 0F91      		pop r16
 331 0060 0FBF      		out __SREG__,r16
 332 0062 0F91      		pop r16
 333 0064 1F91      		pop r17
 334 0066 1895      		reti
 335               		.cfi_endproc
 336               	.LFE8:
 338               	.global	__vector_6
 340               	__vector_6:
 341               	.LFB9:
 227:main.c        **** 
 228:main.c        **** //OCR0A interrupt handler
 229:main.c        **** ISR(TIM0_COMPB_vect){
 342               		.loc 1 229 0
 343               		.cfi_startproc
 344 0068 1F93      		push r17
 345               	.LCFI8:
 346               		.cfi_def_cfa_offset 3
 347               		.cfi_offset 17, -2
 348 006a 0F93      		push r16
 349               	.LCFI9:
 350               		.cfi_def_cfa_offset 4
 351               		.cfi_offset 16, -3
 352 006c 0FB7      		in r16,__SREG__
 353 006e 0F93      		push r16
 354 0070 10E0      		ldi __zero_reg__,lo8(0)
 355 0072 6F93      		push r22
 356               	.LCFI10:
 357               		.cfi_def_cfa_offset 5
 358               		.cfi_offset 22, -4
 359 0074 7F93      		push r23
 360               	.LCFI11:
 361               		.cfi_def_cfa_offset 6
 362               		.cfi_offset 23, -5
 363 0076 8F93      		push r24
 364               	.LCFI12:
 365               		.cfi_def_cfa_offset 7
 366               		.cfi_offset 24, -6
 367 0078 9F93      		push r25
 368               	.LCFI13:
 369               		.cfi_def_cfa_offset 8
 370               		.cfi_offset 25, -7
 371               	/* prologue: Signal */
 372               	/* frame size = 0 */
 373               	/* stack size = 7 */
 374               	.L__stack_usage = 7
 230:main.c        **** 
 231:main.c        ****     //allow touch to interrupt
 232:main.c        ****     sei();
 375               		.loc 1 232 0
 376               	/* #APP */
 377               	 ;  232 "main.c" 1
 378 007a 7894      		sei
 379               	 ;  0 "" 2
 233:main.c        **** 
 234:main.c        ****     //update OCR0A (always to reduce jitter)
 235:main.c        ****     OCR0A += UART_OCR_INC;
 380               		.loc 1 235 0
 381               	/* #NOAPP */
 382 007c 86B5      		in r24,38-0
 383 007e 97B5      		in r25,38+1-0
 384 0080 8E53      		subi r24,lo8(-(194))
 385 0082 9F4F      		sbci r25,hi8(-(194))
 386 0084 97BD      		out 38+1-0,r25
 387 0086 86BD      		out 38-0,r24
 236:main.c        **** 
 237:main.c        ****     //update RX and TX
 238:main.c        ****     if(tx_cnt == UART_START){
 388               		.loc 1 238 0
 389 0088 80A0      		lds r24,tx_cnt
 390 008a 8823      		tst r24
 391 008c 01F4      		brne .L18
 239:main.c        ****         //don't store sample, set TX low
 240:main.c        ****         CLR(PORTB,UART_TX_PIN);
 392               		.loc 1 240 0
 393 008e 1398      		cbi 2-0,3
 241:main.c        ****         //icrement tx counter
 242:main.c        ****         tx_cnt++;
 394               		.loc 1 242 0
 395 0090 81E0      		ldi r24,lo8(1)
 396 0092 80A8      		sts tx_cnt,r24
 397 0094 00C0      		rjmp .L17
 398               	.L18:
 243:main.c        ****     } else if (tx_cnt < UART_STOP) {
 399               		.loc 1 243 0
 400 0096 8930      		cpi r24,lo8(9)
 401 0098 00F4      		brsh .L20
 244:main.c        ****         //store RX samle
 245:main.c        ****         cur_rx |= ((PINB >> 2) & 0x01);
 402               		.loc 1 245 0
 403 009a 80B1      		in r24,0-0
 404 009c 8695      		lsr r24
 405 009e 8695      		lsr r24
 406 00a0 8170      		andi r24,lo8(1)
 407 00a2 90A0      		lds r25,cur_rx
 408 00a4 892B      		or r24,r25
 246:main.c        ****         cur_rx = (cur_rx << 1);
 409               		.loc 1 246 0
 410 00a6 880F      		lsl r24
 411 00a8 80A8      		sts cur_rx,r24
 247:main.c        ****         //set TX output
 248:main.c        ****         PORTB  = (PORTB & ~(1 << UART_TX_PIN)) | ((cur_tx & 0x01) << UART_TX_PIN);
 412               		.loc 1 248 0
 413 00aa 62B1      		in r22,2-0
 414 00ac 70A0      		lds r23,cur_tx
 415 00ae 872F      		mov r24,r23
 416 00b0 90E0      		ldi r25,lo8(0)
 417 00b2 8170      		andi r24,lo8(1)
 418 00b4 9070      		andi r25,hi8(1)
 419 00b6 880F      		lsl r24
 420 00b8 991F      		rol r25
 421 00ba 880F      		lsl r24
 422 00bc 991F      		rol r25
 423 00be 880F      		lsl r24
 424 00c0 991F      		rol r25
 425 00c2 677F      		andi r22,lo8(-9)
 426 00c4 682B      		or r22,r24
 427 00c6 62B9      		out 2-0,r22
 249:main.c        ****         cur_tx = (cur_tx >> 1);
 428               		.loc 1 249 0
 429 00c8 7695      		lsr r23
 430 00ca 70A8      		sts cur_tx,r23
 431 00cc 00C0      		rjmp .L17
 432               	.L20:
 250:main.c        ****         //increment tx counter
 251:main.c        ****     } else {
 252:main.c        ****         //don't sample, set TX high
 253:main.c        ****         SET(PORTB,UART_TX_PIN);
 433               		.loc 1 253 0
 434 00ce 139A      		sbi 2-0,3
 254:main.c        ****         //disable this interrupt until next RX byte
 255:main.c        ****         CLR(TIMSK0,OCIE0B);
 435               		.loc 1 255 0
 436 00d0 8BB5      		in r24,43-0
 437 00d2 8B7F      		andi r24,lo8(-5)
 438 00d4 8BBD      		out 43-0,r24
 256:main.c        ****         //we are done, set tx_counter to 0
 257:main.c        ****         tx_cnt = 0x00;
 439               		.loc 1 257 0
 440 00d6 10A8      		sts tx_cnt,__zero_reg__
 258:main.c        **** 
 259:main.c        ****         //cur_rx done, check if message is for us
 260:main.c        ****         if( IS_SET(cur_rx,MSG_SLOT_TAKEN) && IS_SET(state,TAKEN_PASSED) ){
 441               		.loc 1 260 0
 442 00d8 80A0      		lds r24,cur_rx
 443 00da 80FF      		sbrs r24,0
 444 00dc 00C0      		rjmp .L21
 445               		.loc 1 260 0 is_stmt 0 discriminator 1
 446 00de 90A0      		lds r25,state
 447 00e0 90FF      		sbrs r25,0
 448 00e2 00C0      		rjmp .L21
 261:main.c        **** 
 262:main.c        ****             //if for us, store settings, refresh button state
 263:main.c        ****             state = (cur_rx & ~CONF_BIT_MASK) | (state & CONF_BIT_MASK);
 449               		.loc 1 263 0 is_stmt 1
 450 00e4 9971      		andi r25,lo8(25)
 451 00e6 682F      		mov r22,r24
 452 00e8 667E      		andi r22,lo8(-26)
 453 00ea 962B      		or r25,r22
 264:main.c        ****             cur_tx = cur_rx | B(MSG_SLOT_TAKEN) | IS_SET(state,TOUCHED);
 454               		.loc 1 264 0
 455 00ec 692F      		mov r22,r25
 456 00ee 6870      		andi r22,lo8(8)
 457 00f0 8160      		ori r24,lo8(1)
 458 00f2 682B      		or r22,r24
 459 00f4 60A8      		sts cur_tx,r22
 265:main.c        ****             //update state flags
 266:main.c        ****             state &= ~B(TAKEN_PASSED) & ~B(TOUCHED);
 460               		.loc 1 266 0
 461 00f6 967F      		andi r25,lo8(-10)
 462 00f8 90A8      		sts state,r25
 267:main.c        ****             //set led PWM output based on new config (only control upper bits, rest 1)
 268:main.c        ****             OCR0AH = ~CONF_LED_MASK | state;
 463               		.loc 1 268 0
 464 00fa 9F61      		ori r25,lo8(31)
 465 00fc 97BD      		out 39-0,r25
 269:main.c        ****             OCR0AL = 0xFF;
 466               		.loc 1 269 0
 467 00fe 8FEF      		ldi r24,lo8(-1)
 468 0100 86BD      		out 38-0,r24
 469 0102 00C0      		rjmp .L22
 470               	.L21:
 270:main.c        **** 
 271:main.c        ****         } else {
 272:main.c        ****             //if not for us pass on untouched
 273:main.c        ****             cur_tx = cur_rx;
 471               		.loc 1 273 0
 472 0104 80A8      		sts cur_tx,r24
 473               	.L22:
 274:main.c        ****         }
 275:main.c        **** 
 276:main.c        ****         //go to uart idle state (enable EXTI)
 277:main.c        ****         EIFR  = (1<<INTF0); //clear external interrupt state
 474               		.loc 1 277 0
 475 0106 81E0      		ldi r24,lo8(1)
 476 0108 84BB      		out 20-0,r24
 278:main.c        ****         EIMSK = (1 << INT0);
 477               		.loc 1 278 0
 478 010a 83BB      		out 19-0,r24
 479               	.L17:
 480               	/* epilogue start */
 279:main.c        ****     }
 280:main.c        **** 
 281:main.c        **** }
 481               		.loc 1 281 0
 482 010c 9F91      		pop r25
 483 010e 8F91      		pop r24
 484 0110 7F91      		pop r23
 485 0112 6F91      		pop r22
 486 0114 0F91      		pop r16
 487 0116 0FBF      		out __SREG__,r16
 488 0118 0F91      		pop r16
 489 011a 1F91      		pop r17
 490 011c 1895      		reti
 491               		.cfi_endproc
 492               	.LFE9:
 494               	.global	__vector_4
 496               	__vector_4:
 497               	.LFB10:
 282:main.c        **** 
 283:main.c        **** 
 284:main.c        **** 
 285:main.c        **** #if LED_PIN != PIN0
 286:main.c        **** #  error "change interrupt routines when changing LED_PIN definition"
 287:main.c        **** #endif
 288:main.c        **** #if TOUCH_PIN != PIN1
 289:main.c        **** #  error "change interrupt routines when changing TOUCH_PIN definition"
 290:main.c        **** #endif
 291:main.c        **** 
 292:main.c        **** //TIM0 overflow handler,
 293:main.c        **** //Start touch measurement by setting pin to input
 294:main.c        **** //also clear led pin, for PWM (pwm mode does not allow 0xFFFF as top....)
 295:main.c        **** ISR(TIM0_OVF_vect, ISR_NAKED){
 498               		.loc 1 295 0
 499               		.cfi_startproc
 500               	/* prologue: naked */
 501               	/* frame size = 0 */
 502               	/* stack size = 0 */
 503               	.L__stack_usage = 0
 296:main.c        ****     //set cap_touch pin to input pin to input
 297:main.c        ****     //PORTB &= ~(1 << LED_PIN);
 298:main.c        ****     //DDRB &= ~(1 << TOUCH_PIN);
 299:main.c        ****     asm("cbi 2,0");
 504               		.loc 1 299 0
 505               	/* #APP */
 506               	 ;  299 "main.c" 1
 507 011e 1098      		cbi 2,0
 508               	 ;  0 "" 2
 300:main.c        ****     asm("cbi 1,1");
 509               		.loc 1 300 0
 510               	 ;  300 "main.c" 1
 511 0120 0998      		cbi 1,1
 512               	 ;  0 "" 2
 301:main.c        ****     asm("reti");
 513               		.loc 1 301 0
 514               	 ;  301 "main.c" 1
 515 0122 1895      		reti
 516               	 ;  0 "" 2
 517               	/* epilogue start */
 302:main.c        **** }
 518               		.loc 1 302 0
 519               	/* #NOAPP */
 520               		.cfi_endproc
 521               	.LFE10:
 523               	.global	__vector_5
 525               	__vector_5:
 526               	.LFB11:
 303:main.c        **** 
 304:main.c        **** 
 305:main.c        **** //kind of stupid, but needed since non-pwm mode makes PWM generation hard
 306:main.c        **** //cannot set to PWM mode because the TOP values are either changing
 307:main.c        **** //OC0A, OC0B and ICR, or TOP value is too low (0x03FF max).
 308:main.c        **** ISR(TIM0_COMPA_vect, ISR_NAKED){
 527               		.loc 1 308 0
 528               		.cfi_startproc
 529               	/* prologue: naked */
 530               	/* frame size = 0 */
 531               	/* stack size = 0 */
 532               	.L__stack_usage = 0
 309:main.c        ****     //set cap_touch pin to input pin to input
 310:main.c        ****     //PORTB &= ~(1 << LED_PIN);
 311:main.c        ****     //DDRB &= ~(1 << TOUCH_PIN);
 312:main.c        ****     asm("sbi 2,0");
 533               		.loc 1 312 0
 534               	/* #APP */
 535               	 ;  312 "main.c" 1
 536 0124 109A      		sbi 2,0
 537               	 ;  0 "" 2
 313:main.c        ****     asm("reti");
 538               		.loc 1 313 0
 539               	 ;  313 "main.c" 1
 540 0126 1895      		reti
 541               	 ;  0 "" 2
 542               	/* epilogue start */
 314:main.c        **** }
 543               		.loc 1 314 0
 544               	/* #NOAPP */
 545               		.cfi_endproc
 546               	.LFE11:
 548               		.comm touch_avg,2,1
 549               		.comm touch_new,2,1
 550               		.comm touch_cnt,1,1
 551               		.comm led_val,1,1
 552               		.comm state,1,1
 553               		.comm tx_cnt,1,1
 554               		.comm cur_tx,1,1
 555               		.comm cur_rx,1,1
 556               		.comm cur_touch,1,1
 557               		.comm cur_conf,1,1
 558               		.comm cur_meas,2,1
 559               	.Letext0:
 560               		.file 2 "/opt/cross/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccPUBJMZ.s:2      *ABS*:000000000000003f __SREG__
     /tmp/ccPUBJMZ.s:3      *ABS*:000000000000003e __SP_H__
     /tmp/ccPUBJMZ.s:4      *ABS*:000000000000003d __SP_L__
     /tmp/ccPUBJMZ.s:5      *ABS*:000000000000003c __CCP__
     /tmp/ccPUBJMZ.s:6      *ABS*:0000000000000010 __tmp_reg__
     /tmp/ccPUBJMZ.s:7      *ABS*:0000000000000011 __zero_reg__
     /tmp/ccPUBJMZ.s:15     .text:0000000000000000 init
                            *COM*:0000000000000001 cur_rx
     /tmp/ccPUBJMZ.s:82     .text.startup:0000000000000000 main
                            *COM*:0000000000000002 touch_new
                            *COM*:0000000000000002 touch_avg
                            *COM*:0000000000000001 touch_cnt
                            *COM*:0000000000000001 state
     /tmp/ccPUBJMZ.s:280    .text:0000000000000036 __vector_1
     /tmp/ccPUBJMZ.s:340    .text:0000000000000068 __vector_6
                            *COM*:0000000000000001 tx_cnt
                            *COM*:0000000000000001 cur_tx
     /tmp/ccPUBJMZ.s:496    .text:000000000000011e __vector_4
     /tmp/ccPUBJMZ.s:525    .text:0000000000000124 __vector_5
                            *COM*:0000000000000001 led_val
                            *COM*:0000000000000001 cur_touch
                            *COM*:0000000000000001 cur_conf
                            *COM*:0000000000000002 cur_meas

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
