   1               		.file	"main.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x3c
   6               	__tmp_reg__ = 16
   7               	__zero_reg__ = 17
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  10               		.text
  11               	.Ltext0:
  12               		.cfi_sections	.debug_frame
  13               	.global	init
  15               	init:
  16               	.LFB7:
  17               		.file 1 "main.c"
   1:main.c        **** #include <util/delay.h>
   2:main.c        **** #include <avr/io.h>
   3:main.c        **** #include <avr/interrupt.h>
   4:main.c        **** 
   5:main.c        **** #define TRUE (1)
   6:main.c        **** #define FALSE (0)
   7:main.c        **** 
   8:main.c        **** 
   9:main.c        **** 
  10:main.c        **** #define OCR_INCREMENT ((uint16_t)417)
  11:main.c        **** 
  12:main.c        **** 
  13:main.c        **** void init(void);
  14:main.c        **** 
  15:main.c        **** #define TOUCH_TIMEOUT ((uint16_t)40000) //roughly 4ms @ 8MHz
  16:main.c        **** #define TOUCH_PIN (PIN1) //TODO: set proper pin (change interrupt)
  17:main.c        **** 
  18:main.c        **** 
  19:main.c        **** //the number of instructions before INT0 is executed
  20:main.c        **** #define ISR_OFFSET     (4+10) //4 till call, 10 till instruction
  21:main.c        **** 
  22:main.c        **** //next sample instant 1/19200 = 52us =~ 417 tim-ticks @ 8MHz
  23:main.c        **** #define UART_BIT_TIME       ((uint16_t)417) //number of clock ticks @8MHz per bit
  24:main.c        **** 
  25:main.c        **** #define UART_OCR_OFFSET     (4+10) //4 till call, 10 till instruction
  26:main.c        **** #define UART_OCR_INC        ((UART_BIT_TIME / 2)-UART_OCR_OFFSET)
  27:main.c        **** #define UART_HALF_OCR_INC   (UART_BIT_TIME-UART_OCR_OFFSET)
  28:main.c        **** 
  29:main.c        **** #define UART_RX_PIN    (PB2)
  30:main.c        **** #define UART_TX_PIN    (PB3)
  31:main.c        **** #define UART_START     (0)
  32:main.c        **** #define UART_STOP      (9)
  33:main.c        **** 
  34:main.c        **** //protocol definitions
  35:main.c        **** #define SLOT_TAKEN_BIT (7)
  36:main.c        **** 
  37:main.c        **** uint16_t       cur_meas;
  38:main.c        **** uint8_t cur_conf,cur_touch;
  39:main.c        **** uint8_t cur_rx,cur_tx,tx_cnt;
  40:main.c        **** 
  41:main.c        **** int main(void) {
  42:main.c        **** 
  43:main.c        ****   init();
  44:main.c        **** 
  45:main.c        ****   while(TRUE){
  46:main.c        **** 
  47:main.c        ****       //if uart cycle has completed (both interrupts disabled) prepare next
  48:main.c        ****       if( ( EIMSK & (1 << INT0) ) && ( TIMSK0 & (1 << OCIE0B) ) )
  49:main.c        ****       {
  50:main.c        **** 
  51:main.c        ****           //check if  is for us
  52:main.c        ****           if(cur_rx & (1 << SLOT_TAKEN_BIT)){
  53:main.c        ****               //if for us, store settings, refresh button state
  54:main.c        ****               cur_conf = cur_rx;
  55:main.c        ****               cur_tx = cur_rx | (1<<SLOT_TAKEN_BIT) | cur_touch;
  56:main.c        ****           } else {
  57:main.c        ****               //if not for us pass on untouched
  58:main.c        ****               cur_tx = cur_rx;
  59:main.c        ****           }
  60:main.c        **** 
  61:main.c        ****           //go to uart idle state (enable EXTI)
  62:main.c        ****           EIFR  = (1<<INTF0); //clear external interrupt state
  63:main.c        ****           EIMSK = (1 << INT0);
  64:main.c        **** 
  65:main.c        ****       }
  66:main.c        **** 
  67:main.c        ****       //check for touch timeout / process measurement
  68:main.c        ****       if( (TCNT0 >= TOUCH_TIMEOUT) && (TIFR0 & (1 << TOV0))  ) {
  69:main.c        ****           //disable touch interrupt
  70:main.c        ****           TIMSK0 &= (1 << TOIE0);
  71:main.c        ****           //set touch pin to output
  72:main.c        ****           DDRB |= (1 << TOUCH_PIN);
  73:main.c        ****           //process measurement
  74:main.c        ****                   //....
  75:main.c        ****           //start new measurement
  76:main.c        ****           TIMSK0 |= (1 << TOIE0);
  77:main.c        ****       }
  78:main.c        **** 
  79:main.c        ****       //process state
  80:main.c        **** 
  81:main.c        **** 
  82:main.c        ****   }
  83:main.c        **** 
  84:main.c        ****   return 0;
  85:main.c        **** }
  86:main.c        **** 
  87:main.c        **** 
  88:main.c        **** void init(void){
  18               		.loc 1 88 0
  19               		.cfi_startproc
  20               	/* prologue: function */
  21               	/* frame size = 0 */
  22               	/* stack size = 0 */
  23               	.L__stack_usage = 0
  89:main.c        **** 
  90:main.c        ****     //set clock to 8Mhz, no prescaler, factory calibration
  91:main.c        ****     CLKMSR = 0x00;
  24               		.loc 1 91 0
  25 0000 17BF      		out 55-0,__zero_reg__
  92:main.c        ****     OSCCAL = 0x00;
  26               		.loc 1 92 0
  27 0002 19BF      		out 57-0,__zero_reg__
  93:main.c        ****     CLKPSR = 0x00;
  28               		.loc 1 93 0
  29 0004 16BF      		out 54-0,__zero_reg__
  94:main.c        **** 
  95:main.c        ****     //set timer to CTC mode, no output compare, no prescaler
  96:main.c        ****     //reset on OCROB = floor(65536 / OCR_INCREMENT) * OCR_INCREMEN
  97:main.c        ****     //interrupt on OVF and OCIE0A
  98:main.c        ****     TCCR0A = 0x00;
  30               		.loc 1 98 0
  31 0006 1EBD      		out 46-0,__zero_reg__
  99:main.c        ****     TCCR0B = 0x00; //leave timer disabled for now (1<<CS00);
  32               		.loc 1 99 0
  33 0008 1DBD      		out 45-0,__zero_reg__
 100:main.c        ****     TIMSK0 = (1<<TOIE0) | (1<<OCIE0A) | (1<<OCIE0B);
  34               		.loc 1 100 0
  35 000a 87E0      		ldi r24,lo8(7)
  36 000c 8BBD      		out 43-0,r24
  37               	/* epilogue start */
 101:main.c        ****     //set first compare value to 1/19200/2 = 26us = 208 tim-ticks @ 8MHz
 102:main.c        ****     //TODO: verify 16 bit access
 103:main.c        **** 
 104:main.c        **** 
 105:main.c        ****     //GPIO init
 106:main.c        ****     //set led and touch to output
 107:main.c        ****     //set one pin to output for uart
 108:main.c        ****     //the other to input with pullup for uart
 109:main.c        **** 
 110:main.c        **** 
 111:main.c        **** }
  38               		.loc 1 111 0
  39 000e 0895      		ret
  40               		.cfi_endproc
  41               	.LFE7:
  43               		.section	.text.startup,"ax",@progbits
  44               	.global	main
  46               	main:
  47               	.LFB6:
  41:main.c        **** int main(void) {
  48               		.loc 1 41 0
  49               		.cfi_startproc
  50               	/* prologue: function */
  51               	/* frame size = 0 */
  52               	/* stack size = 0 */
  53               	.L__stack_usage = 0
  43:main.c        ****   init();
  54               		.loc 1 43 0
  55 0000 00D0      		rcall init
  62:main.c        ****           EIFR  = (1<<INTF0); //clear external interrupt state
  56               		.loc 1 62 0
  57 0002 61E0      		ldi r22,lo8(1)
  58               	.L10:
  48:main.c        ****       if( ( EIMSK & (1 << INT0) ) && ( TIMSK0 & (1 << OCIE0B) ) )
  59               		.loc 1 48 0
  60 0004 989B      		sbis 19-0,0
  61 0006 00C0      		rjmp .L4
  48:main.c        ****       if( ( EIMSK & (1 << INT0) ) && ( TIMSK0 & (1 << OCIE0B) ) )
  62               		.loc 1 48 0 is_stmt 0 discriminator 1
  63 0008 0BB5      		in __tmp_reg__,43-0
  64 000a 02FF      		sbrs __tmp_reg__,2
  65 000c 00C0      		rjmp .L4
  52:main.c        ****           if(cur_rx & (1 << SLOT_TAKEN_BIT)){
  66               		.loc 1 52 0 is_stmt 1
  67 000e 90A0      		lds r25,cur_rx
  68 0010 97FF      		sbrs r25,7
  69 0012 00C0      		rjmp .L5
  54:main.c        ****               cur_conf = cur_rx;
  70               		.loc 1 54 0
  71 0014 90A8      		sts cur_conf,r25
  55:main.c        ****               cur_tx = cur_rx | (1<<SLOT_TAKEN_BIT) | cur_touch;
  72               		.loc 1 55 0
  73 0016 80A0      		lds r24,cur_touch
  74 0018 892B      		or r24,r25
  75 001a 8068      		ori r24,lo8(-128)
  76 001c 80A8      		sts cur_tx,r24
  77 001e 00C0      		rjmp .L6
  78               	.L5:
  58:main.c        ****               cur_tx = cur_rx;
  79               		.loc 1 58 0
  80 0020 90A8      		sts cur_tx,r25
  81               	.L6:
  62:main.c        ****           EIFR  = (1<<INTF0); //clear external interrupt state
  82               		.loc 1 62 0
  83 0022 64BB      		out 20-0,r22
  63:main.c        ****           EIMSK = (1 << INT0);
  84               		.loc 1 63 0
  85 0024 63BB      		out 19-0,r22
  86               	.L4:
  68:main.c        ****       if( (TCNT0 >= TOUCH_TIMEOUT) && (TIFR0 & (1 << TOV0))  ) {
  87               		.loc 1 68 0
  88 0026 88B5      		in r24,40-0
  89 0028 99B5      		in r25,40+1-0
  90 002a 7CE9      		ldi r23,hi8(-25536)
  91 002c 8034      		cpi r24,lo8(-25536)
  92 002e 9707      		cpc r25,r23
  93 0030 00F0      		brlo .L10
  68:main.c        ****       if( (TCNT0 >= TOUCH_TIMEOUT) && (TIFR0 & (1 << TOV0))  ) {
  94               		.loc 1 68 0 is_stmt 0 discriminator 1
  95 0032 0AB5      		in __tmp_reg__,42-0
  96 0034 00FF      		sbrs __tmp_reg__,0
  97 0036 00C0      		rjmp .L10
  70:main.c        ****           TIMSK0 &= (1 << TOIE0);
  98               		.loc 1 70 0 is_stmt 1
  99 0038 8BB5      		in r24,43-0
 100 003a 8170      		andi r24,lo8(1)
 101 003c 8BBD      		out 43-0,r24
  72:main.c        ****           DDRB |= (1 << TOUCH_PIN);
 102               		.loc 1 72 0
 103 003e 099A      		sbi 1-0,1
  76:main.c        ****           TIMSK0 |= (1 << TOIE0);
 104               		.loc 1 76 0
 105 0040 8BB5      		in r24,43-0
 106 0042 8160      		ori r24,lo8(1)
 107 0044 8BBD      		out 43-0,r24
 108 0046 00C0      		rjmp .L10
 109               		.cfi_endproc
 110               	.LFE6:
 112               		.text
 113               	.global	__vector_1
 115               	__vector_1:
 116               	.LFB8:
 112:main.c        **** 
 113:main.c        **** 
 114:main.c        **** 
 115:main.c        **** 
 116:main.c        **** 
 117:main.c        **** 
 118:main.c        **** //=====================================
 119:main.c        **** //INTERRUPT HANDLERS
 120:main.c        **** //=====================================
 121:main.c        **** 
 122:main.c        **** //external interrupt (start of UART RX)
 123:main.c        **** ISR(INT0_vect){
 117               		.loc 1 123 0
 118               		.cfi_startproc
 119 0010 1F93      		push r17
 120               	.LCFI0:
 121               		.cfi_def_cfa_offset 3
 122               		.cfi_offset 17, -2
 123 0012 0F93      		push r16
 124               	.LCFI1:
 125               		.cfi_def_cfa_offset 4
 126               		.cfi_offset 16, -3
 127 0014 0FB7      		in r16,__SREG__
 128 0016 0F93      		push r16
 129 0018 10E0      		ldi __zero_reg__,lo8(0)
 130 001a 8F93      		push r24
 131               	.LCFI2:
 132               		.cfi_def_cfa_offset 5
 133               		.cfi_offset 24, -4
 134 001c 9F93      		push r25
 135               	.LCFI3:
 136               		.cfi_def_cfa_offset 6
 137               		.cfi_offset 25, -5
 138               	/* prologue: Signal */
 139               	/* frame size = 0 */
 140               	/* stack size = 5 */
 141               	.L__stack_usage = 5
 124:main.c        **** 
 125:main.c        ****     //allow touch to interrupt
 126:main.c        ****     sei();
 142               		.loc 1 126 0
 143               	/* #APP */
 144               	 ;  126 "main.c" 1
 145 001e 7894      		sei
 146               	 ;  0 "" 2
 127:main.c        **** 
 128:main.c        ****     //set first sample time
 129:main.c        ****     OCR0A = TCNT0+UART_HALF_OCR_INC;
 147               		.loc 1 129 0
 148               	/* #NOAPP */
 149 0020 88B5      		in r24,40-0
 150 0022 99B5      		in r25,40+1-0
 151 0024 8D56      		subi r24,lo8(-(403))
 152 0026 9E4F      		sbci r25,hi8(-(403))
 153 0028 97BD      		out 38+1-0,r25
 154 002a 86BD      		out 38-0,r24
 130:main.c        ****     //disable external interrupt, enable COMPA interrupt
 131:main.c        ****     EIMSK = 0x00;
 155               		.loc 1 131 0
 156 002c 13BB      		out 19-0,__zero_reg__
 132:main.c        ****     TIMSK0 |= (1<<OCIE0B);
 157               		.loc 1 132 0
 158 002e 8BB5      		in r24,43-0
 159 0030 8460      		ori r24,lo8(4)
 160 0032 8BBD      		out 43-0,r24
 161               	/* epilogue start */
 133:main.c        **** 
 134:main.c        **** }
 162               		.loc 1 134 0
 163 0034 9F91      		pop r25
 164 0036 8F91      		pop r24
 165 0038 0F91      		pop r16
 166 003a 0FBF      		out __SREG__,r16
 167 003c 0F91      		pop r16
 168 003e 1F91      		pop r17
 169 0040 1895      		reti
 170               		.cfi_endproc
 171               	.LFE8:
 173               	.global	__vector_6
 175               	__vector_6:
 176               	.LFB9:
 135:main.c        **** 
 136:main.c        **** //OCR0A interrupt handler
 137:main.c        **** ISR(TIM0_COMPB_vect){
 177               		.loc 1 137 0
 178               		.cfi_startproc
 179 0042 1F93      		push r17
 180               	.LCFI4:
 181               		.cfi_def_cfa_offset 3
 182               		.cfi_offset 17, -2
 183 0044 0F93      		push r16
 184               	.LCFI5:
 185               		.cfi_def_cfa_offset 4
 186               		.cfi_offset 16, -3
 187 0046 0FB7      		in r16,__SREG__
 188 0048 0F93      		push r16
 189 004a 10E0      		ldi __zero_reg__,lo8(0)
 190 004c 6F93      		push r22
 191               	.LCFI6:
 192               		.cfi_def_cfa_offset 5
 193               		.cfi_offset 22, -4
 194 004e 7F93      		push r23
 195               	.LCFI7:
 196               		.cfi_def_cfa_offset 6
 197               		.cfi_offset 23, -5
 198 0050 8F93      		push r24
 199               	.LCFI8:
 200               		.cfi_def_cfa_offset 7
 201               		.cfi_offset 24, -6
 202 0052 9F93      		push r25
 203               	.LCFI9:
 204               		.cfi_def_cfa_offset 8
 205               		.cfi_offset 25, -7
 206               	/* prologue: Signal */
 207               	/* frame size = 0 */
 208               	/* stack size = 7 */
 209               	.L__stack_usage = 7
 138:main.c        **** 
 139:main.c        ****     //allow touch to interrupt
 140:main.c        ****     sei();
 210               		.loc 1 140 0
 211               	/* #APP */
 212               	 ;  140 "main.c" 1
 213 0054 7894      		sei
 214               	 ;  0 "" 2
 141:main.c        **** 
 142:main.c        ****     //update OCR0A (always to reduce jitter)
 143:main.c        ****     OCR0A += UART_OCR_INC;
 215               		.loc 1 143 0
 216               	/* #NOAPP */
 217 0056 86B5      		in r24,38-0
 218 0058 97B5      		in r25,38+1-0
 219 005a 8E53      		subi r24,lo8(-(194))
 220 005c 9F4F      		sbci r25,hi8(-(194))
 221 005e 97BD      		out 38+1-0,r25
 222 0060 86BD      		out 38-0,r24
 144:main.c        **** 
 145:main.c        ****     //update RX and TX
 146:main.c        ****     if(tx_cnt == UART_START){
 223               		.loc 1 146 0
 224 0062 80A0      		lds r24,tx_cnt
 225 0064 8823      		tst r24
 226 0066 01F4      		brne .L13
 147:main.c        ****         //don't store sample, set TX low
 148:main.c        ****         PORTB &= ~(1 << UART_TX_PIN);
 227               		.loc 1 148 0
 228 0068 1398      		cbi 2-0,3
 149:main.c        ****         //icrement tx counter
 150:main.c        ****         tx_cnt++;
 229               		.loc 1 150 0
 230 006a 81E0      		ldi r24,lo8(1)
 231 006c 80A8      		sts tx_cnt,r24
 232 006e 00C0      		rjmp .L12
 233               	.L13:
 151:main.c        ****     } else if (tx_cnt < UART_STOP) {
 234               		.loc 1 151 0
 235 0070 8930      		cpi r24,lo8(9)
 236 0072 00F4      		brsh .L15
 152:main.c        ****         //store RX samle
 153:main.c        ****         cur_rx |= ((PINB >> 2) & 0x01);
 237               		.loc 1 153 0
 238 0074 80B1      		in r24,0-0
 239 0076 8695      		lsr r24
 240 0078 8695      		lsr r24
 241 007a 8170      		andi r24,lo8(1)
 242 007c 90A0      		lds r25,cur_rx
 243 007e 892B      		or r24,r25
 154:main.c        ****         cur_rx = (cur_rx << 1);
 244               		.loc 1 154 0
 245 0080 880F      		lsl r24
 246 0082 80A8      		sts cur_rx,r24
 155:main.c        ****         //set TX output
 156:main.c        ****         PORTB  = (PORTB & ~(1 << UART_TX_PIN)) | ((cur_tx & 0x01) << UART_TX_PIN);
 247               		.loc 1 156 0
 248 0084 62B1      		in r22,2-0
 249 0086 70A0      		lds r23,cur_tx
 250 0088 872F      		mov r24,r23
 251 008a 90E0      		ldi r25,lo8(0)
 252 008c 8170      		andi r24,lo8(1)
 253 008e 9070      		andi r25,hi8(1)
 254 0090 880F      		lsl r24
 255 0092 991F      		rol r25
 256 0094 880F      		lsl r24
 257 0096 991F      		rol r25
 258 0098 880F      		lsl r24
 259 009a 991F      		rol r25
 260 009c 677F      		andi r22,lo8(-9)
 261 009e 682B      		or r22,r24
 262 00a0 62B9      		out 2-0,r22
 157:main.c        ****         cur_tx = (cur_tx >> 1);
 263               		.loc 1 157 0
 264 00a2 7695      		lsr r23
 265 00a4 70A8      		sts cur_tx,r23
 266 00a6 00C0      		rjmp .L12
 267               	.L15:
 158:main.c        ****         //increment tx counter
 159:main.c        ****     } else {
 160:main.c        ****         //don't sample, set TX high
 161:main.c        ****         PORTB |= (1<<UART_TX_PIN);
 268               		.loc 1 161 0
 269 00a8 139A      		sbi 2-0,3
 162:main.c        ****         //enable external interrupt, enable COMPA interrupt
 163:main.c        ****         //EIMSK = 0x01; TODO:think about sync with main
 164:main.c        ****         TIMSK0 &= ~(1<<OCIE0B);
 270               		.loc 1 164 0
 271 00aa 8BB5      		in r24,43-0
 272 00ac 8B7F      		andi r24,lo8(-5)
 273 00ae 8BBD      		out 43-0,r24
 165:main.c        ****         //we are done, set tx_counter to 0
 166:main.c        ****         tx_cnt = 0x00;
 274               		.loc 1 166 0
 275 00b0 10A8      		sts tx_cnt,__zero_reg__
 276               	.L12:
 277               	/* epilogue start */
 167:main.c        ****     }
 168:main.c        **** 
 169:main.c        **** }
 278               		.loc 1 169 0
 279 00b2 9F91      		pop r25
 280 00b4 8F91      		pop r24
 281 00b6 7F91      		pop r23
 282 00b8 6F91      		pop r22
 283 00ba 0F91      		pop r16
 284 00bc 0FBF      		out __SREG__,r16
 285 00be 0F91      		pop r16
 286 00c0 1F91      		pop r17
 287 00c2 1895      		reti
 288               		.cfi_endproc
 289               	.LFE9:
 291               	.global	__vector_4
 293               	__vector_4:
 294               	.LFB10:
 170:main.c        **** 
 171:main.c        **** 
 172:main.c        **** //TIM0 overflow handler,
 173:main.c        **** //Start touch measurement by setting pin to input
 174:main.c        **** ISR(TIM0_OVF_vect, ISR_NAKED){
 295               		.loc 1 174 0
 296               		.cfi_startproc
 297               	/* prologue: naked */
 298               	/* frame size = 0 */
 299               	/* stack size = 0 */
 300               	.L__stack_usage = 0
 175:main.c        ****     //set cap_touch pin to input pin to input
 176:main.c        ****     //DDRB &= ~(1 << TOUCH_PIN);
 177:main.c        ****     asm("cbi 1,1");
 301               		.loc 1 177 0
 302               	/* #APP */
 303               	 ;  177 "main.c" 1
 304 00c4 0998      		cbi 1,1
 305               	 ;  0 "" 2
 178:main.c        ****     asm("reti");
 306               		.loc 1 178 0
 307               	 ;  178 "main.c" 1
 308 00c6 1895      		reti
 309               	 ;  0 "" 2
 310               	/* epilogue start */
 179:main.c        **** }
 311               		.loc 1 179 0
 312               	/* #NOAPP */
 313               		.cfi_endproc
 314               	.LFE10:
 316               		.comm tx_cnt,1,1
 317               		.comm cur_tx,1,1
 318               		.comm cur_rx,1,1
 319               		.comm cur_touch,1,1
 320               		.comm cur_conf,1,1
 321               		.comm cur_meas,2,1
 322               	.Letext0:
 323               		.file 2 "/opt/cross/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccqXnD8Y.s:2      *ABS*:000000000000003f __SREG__
     /tmp/ccqXnD8Y.s:3      *ABS*:000000000000003e __SP_H__
     /tmp/ccqXnD8Y.s:4      *ABS*:000000000000003d __SP_L__
     /tmp/ccqXnD8Y.s:5      *ABS*:000000000000003c __CCP__
     /tmp/ccqXnD8Y.s:6      *ABS*:0000000000000010 __tmp_reg__
     /tmp/ccqXnD8Y.s:7      *ABS*:0000000000000011 __zero_reg__
     /tmp/ccqXnD8Y.s:15     .text:0000000000000000 init
     /tmp/ccqXnD8Y.s:46     .text.startup:0000000000000000 main
                            *COM*:0000000000000001 cur_rx
                            *COM*:0000000000000001 cur_conf
                            *COM*:0000000000000001 cur_touch
                            *COM*:0000000000000001 cur_tx
     /tmp/ccqXnD8Y.s:115    .text:0000000000000010 __vector_1
     /tmp/ccqXnD8Y.s:175    .text:0000000000000042 __vector_6
                            *COM*:0000000000000001 tx_cnt
     /tmp/ccqXnD8Y.s:293    .text:00000000000000c4 __vector_4
                            *COM*:0000000000000002 cur_meas

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
