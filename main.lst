   1               		.file	"main.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x3c
   6               	__tmp_reg__ = 16
   7               	__zero_reg__ = 17
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  10               		.text
  11               	.Ltext0:
  12               		.cfi_sections	.debug_frame
  13               	.global	init
  15               	init:
  16               	.LFB8:
  17               		.file 1 "main.c"
   1:main.c        **** #include <util/delay.h>
   2:main.c        **** #include <avr/io.h>
   3:main.c        **** #include <avr/interrupt.h>
   4:main.c        **** 
   5:main.c        **** #define TRUE (1)
   6:main.c        **** #define FALSE (0)
   7:main.c        **** #define TIM_OCR_START ((uint16_t)208)
   8:main.c        **** #define NEW_SAMPLE (0xFF)
   9:main.c        **** #define OLD_SAMPLE (0x00)
  10:main.c        **** #define CAP_TOUCH_PIN (PIN1) //TODO: set proper pin
  11:main.c        **** //next sample instant 1/19200 = 52us =~ 417 tim-ticks @ 8MHz
  12:main.c        **** #define OCR_INCREMENT ((uint16_t)417)
  13:main.c        **** 
  14:main.c        **** 
  15:main.c        **** void init(void);
  16:main.c        **** 
  17:main.c        **** 
  18:main.c        **** uint16_t cur_meas;
  19:main.c        **** uint8_t sample_state;
  20:main.c        **** 
  21:main.c        **** typedef enum uart_state_t {
  22:main.c        ****     IDLE,
  23:main.c        ****     RECEIVING,
  24:main.c        ****     SENDING,
  25:main.c        ****     START,
  26:main.c        ****     STOP
  27:main.c        **** } uart_state_t;
  28:main.c        **** 
  29:main.c        **** //the number of instructions before INT0 is executed
  30:main.c        **** #define ISR_OFFSET     (4+10) //4 till call, 10 till instruction
  31:main.c        **** #define UART_BIT_TIME  ((uint16_t)417) //number of clock ticks @8MHz per bit
  32:main.c        **** #define UART_HALF_BIT_TIME  ((UART_BIT_TIME / 2)-ISR_OFFSET) //number of clock ticks @8MHz per bit
  33:main.c        **** #define UART_BUFF_SIZE (4)
  34:main.c        **** #define UART_RX_BIT    (PB0)
  35:main.c        **** #define UART_TX_BIT    (PB1)
  36:main.c        **** #define UART_RX_PORTx  (PORTB)
  37:main.c        **** #define UART_TX_PORTx  (PORTB)
  38:main.c        **** #define UART_RX_PINx   (PINB)
  39:main.c        **** #define UART_TX_PINx   (PINB)
  40:main.c        **** 
  41:main.c        **** #define HIGH (0xFF)
  42:main.c        **** #define LOW  (0x00)
  43:main.c        **** 
  44:main.c        **** #define UART_SET_START(port,pin) (port &= ~(1<<pin))
  45:main.c        **** #define UART_SET_STOP(port,pin)  (port |= (1<<pin))
  46:main.c        **** #define UART_GET_START(port,pin) (~port & (1<<pin))
  47:main.c        **** 
  48:main.c        **** //uart buffers
  49:main.c        **** //TODO: probably not needed
  50:main.c        **** uint8_t tx[UART_BUFF_SIZE];
  51:main.c        **** uint8_t rx[UART_BUFF_SIZE];
  52:main.c        **** 
  53:main.c        **** uart_state_t rx_state;
  54:main.c        **** uart_state_t tx_state;
  55:main.c        **** 
  56:main.c        **** uint8_t ocr_state;
  57:main.c        **** uint8_t bit_nr;
  58:main.c        **** uint8_t rx_in;
  59:main.c        **** uint8_t cur_rx;
  60:main.c        **** uint8_t cur_tx;
  61:main.c        **** uint8_t tx_out;
  62:main.c        **** uint8_t rx_nr_recv;
  63:main.c        **** uint8_t tx_nr_sent;
  64:main.c        **** uint8_t cur_rx_pos;
  65:main.c        **** uint8_t cur_tx_pos;
  66:main.c        **** uint8_t uart_cnt;
  67:main.c        **** 
  68:main.c        **** 
  69:main.c        **** 
  70:main.c        **** 
  71:main.c        **** static inline void handle_uart_io(void);
  72:main.c        **** 
  73:main.c        **** int main(void) {
  74:main.c        **** 
  75:main.c        ****   init();
  76:main.c        **** 
  77:main.c        ****   while(TRUE){
  78:main.c        **** 
  79:main.c        ****       handle_uart_io();
  80:main.c        **** 
  81:main.c        **** 
  82:main.c        **** 
  83:main.c        **** 
  84:main.c        ****   }
  85:main.c        **** 
  86:main.c        ****   return 0;
  87:main.c        **** }
  88:main.c        **** 
  89:main.c        **** 
  90:main.c        **** static inline void handle_uart_io(void){
  91:main.c        **** 
  92:main.c        ****     //TODO: error checking here (has the sampling interrupt occured?)
  93:main.c        **** 
  94:main.c        ****     //add sample to state, if byte is complete, store in buffer
  95:main.c        **** 
  96:main.c        ****     switch (rx_state){
  97:main.c        **** 
  98:main.c        ****     case IDLE:
  99:main.c        ****         if(rx_in == 0) { //if 0 was received
 100:main.c        ****             rx_state = RECEIVING;
 101:main.c        ****             rx_nr_recv=0;
 102:main.c        ****             cur_rx = 0;
 103:main.c        ****         }
 104:main.c        ****         break;
 105:main.c        **** 
 106:main.c        ****     case RECEIVING :
 107:main.c        ****         //increment number received bits
 108:main.c        ****         rx_nr_recv++;
 109:main.c        ****         //store received bit
 110:main.c        ****         cur_rx |= (rx_in << rx_nr_recv);
 111:main.c        ****         //check if full byte is received
 112:main.c        ****         if(rx_nr_recv == 8){
 113:main.c        ****             rx_state = STOP;
 114:main.c        ****         }
 115:main.c        ****         break;
 116:main.c        **** 
 117:main.c        ****     case STOP :
 118:main.c        ****         if(rx_in){
 119:main.c        ****             rx[cur_rx_pos] = cur_rx;
 120:main.c        ****             rx_state = IDLE;
 121:main.c        ****         }
 122:main.c        ****         break;
 123:main.c        ****     }
 124:main.c        **** 
 125:main.c        **** 
 126:main.c        ****     //handle TX
 127:main.c        ****     switch (tx_state){
 128:main.c        **** 
 129:main.c        ****     case IDLE:
 130:main.c        ****         if(cur_tx_pos != 0) { //if data is waiting
 131:main.c        ****             tx_out = LOW;
 132:main.c        ****             tx_state = SENDING;
 133:main.c        ****             tx_nr_sent=0;
 134:main.c        ****         } else {
 135:main.c        ****             tx_out = HIGH;
 136:main.c        ****         }
 137:main.c        ****         break;
 138:main.c        **** 
 139:main.c        ****     case SENDING :
 140:main.c        ****         //increment number received bits
 141:main.c        ****         tx_nr_sent++;
 142:main.c        ****         //store received bit
 143:main.c        ****         tx_out |= (cur_tx >> tx_nr_sent) & (0x01);
 144:main.c        ****         //check if full byte is received
 145:main.c        ****         if(tx_nr_sent == 8){
 146:main.c        ****             tx_state = STOP;
 147:main.c        ****         }
 148:main.c        ****         break;
 149:main.c        **** 
 150:main.c        ****     case STOP :
 151:main.c        ****         tx_out = HIGH;
 152:main.c        ****         tx_state = IDLE;
 153:main.c        ****         break;
 154:main.c        ****     }
 155:main.c        **** 
 156:main.c        ****     //determine new output bit
 157:main.c        ****         //if in progress, continue
 158:main.c        ****         //if not in progress, but byte in buffer, start
 159:main.c        ****         //if neither, send 1;
 160:main.c        **** 
 161:main.c        **** 
 162:main.c        **** }
 163:main.c        **** 
 164:main.c        **** 
 165:main.c        **** void init(void){
  18               		.loc 1 165 0
  19               		.cfi_startproc
  20               	/* prologue: function */
  21               	/* frame size = 0 */
  22               	/* stack size = 0 */
  23               	.L__stack_usage = 0
 166:main.c        **** 
 167:main.c        ****     //set clock to 8Mhz, no prescaler, factory calibration
 168:main.c        ****     CLKMSR = 0x00;
  24               		.loc 1 168 0
  25 0000 17BF      		out 55-0,__zero_reg__
 169:main.c        ****     OSCCAL = 0x00;
  26               		.loc 1 169 0
  27 0002 19BF      		out 57-0,__zero_reg__
 170:main.c        ****     CLKPSR = 0x00;
  28               		.loc 1 170 0
  29 0004 16BF      		out 54-0,__zero_reg__
 171:main.c        **** 
 172:main.c        ****     //set timer to CTC mode, no output compare, no prescaler
 173:main.c        ****     //reset on OCROB = floor(65536 / OCR_INCREMENT) * OCR_INCREMEN
 174:main.c        ****     //interrupt on OVF and OCIE0A
 175:main.c        ****     TCCR0A = 0x00;
  30               		.loc 1 175 0
  31 0006 1EBD      		out 46-0,__zero_reg__
 176:main.c        ****     TCCR0B = 0x00; //leave timer disabled for now (1<<CS00);
  32               		.loc 1 176 0
  33 0008 1DBD      		out 45-0,__zero_reg__
 177:main.c        ****     TIMSK0 = (1<<TOIE0) | (1<<OCIE0A) | (1<<OCIE0B);
  34               		.loc 1 177 0
  35 000a 87E0      		ldi r24,lo8(7)
  36 000c 8BBD      		out 43-0,r24
 178:main.c        ****     //set first compare value to 1/19200/2 = 26us = 208 tim-ticks @ 8MHz
 179:main.c        ****     //TODO: verify 16 bit access
 180:main.c        ****     OCR0A = TIM_OCR_START;
  37               		.loc 1 180 0
  38 000e 80ED      		ldi r24,lo8(208)
  39 0010 90E0      		ldi r25,hi8(208)
  40 0012 97BD      		out 38+1-0,r25
  41 0014 86BD      		out 38-0,r24
 181:main.c        **** 
 182:main.c        **** 
 183:main.c        ****     //GPIO init
 184:main.c        ****     //set led and touch to output
 185:main.c        ****     //set one pin to output for uart
 186:main.c        ****     //the other to input with pullup for uart
 187:main.c        **** 
 188:main.c        ****     //set sample state to old
 189:main.c        ****     sample_state = OLD_SAMPLE;
  42               		.loc 1 189 0
  43 0016 10A8      		sts sample_state,__zero_reg__
  44               	/* epilogue start */
 190:main.c        **** 
 191:main.c        **** }
  45               		.loc 1 191 0
  46 0018 0895      		ret
  47               		.cfi_endproc
  48               	.LFE8:
  50               		.section	.text.startup,"ax",@progbits
  51               	.global	main
  53               	main:
  54               	.LFB6:
  73:main.c        **** int main(void) {
  55               		.loc 1 73 0
  56               		.cfi_startproc
  57               	/* prologue: function */
  58               	/* frame size = 0 */
  59               	/* stack size = 0 */
  60               	.L__stack_usage = 0
  75:main.c        ****   init();
  61               		.loc 1 75 0
  62 0000 00D0      		rcall init
  63               	.LBB4:
  64               	.LBB5:
 118:main.c        ****         if(rx_in){
  65               		.loc 1 118 0
  66 0002 B0A0      		lds r27,rx_in
 119:main.c        ****             rx[cur_rx_pos] = cur_rx;
  67               		.loc 1 119 0
  68 0004 C0A0      		lds r28,cur_rx_pos
  69 0006 D0E0      		ldi r29,lo8(0)
 110:main.c        ****         cur_rx |= (rx_in << rx_nr_recv);
  70               		.loc 1 110 0
  71 0008 2B2F      		mov r18,r27
  72 000a 30E0      		ldi r19,lo8(0)
 130:main.c        ****         if(cur_tx_pos != 0) { //if data is waiting
  73               		.loc 1 130 0
  74 000c 50A0      		lds r21,cur_tx_pos
  75 000e 70A0      		lds r23,rx_state
  76 0010 E0A0      		lds r30,rx_nr_recv
  77 0012 A0A0      		lds r26,cur_rx
  78 0014 60A0      		lds r22,tx_state
  79 0016 F0A0      		lds r31,tx_nr_sent
 119:main.c        ****             rx[cur_rx_pos] = cur_rx;
  80               		.loc 1 119 0
  81 0018 C050      		subi r28,lo8(-(rx))
  82 001a D040      		sbci r29,hi8(-(rx))
  83 001c 00C0      		rjmp .L15
  84               	.L12:
 152:main.c        ****         tx_state = IDLE;
  85               		.loc 1 152 0
  86 001e 60E0      		ldi r22,lo8(0)
  87               	.L15:
  96:main.c        ****     switch (rx_state){
  88               		.loc 1 96 0 discriminator 1
  89 0020 7130      		cpi r23,lo8(1)
  90 0022 01F0      		breq .L8
  91 0024 7130      		cpi r23,lo8(1)
  92 0026 00F0      		brlo .L7
  93 0028 7430      		cpi r23,lo8(4)
  94 002a 01F4      		brne .L6
  95 002c 00C0      		rjmp .L16
  96               	.L7:
  99:main.c        ****         if(rx_in == 0) { //if 0 was received
  97               		.loc 1 99 0
  98 002e BB23      		tst r27
  99 0030 01F4      		brne .L6
 102:main.c        ****             cur_rx = 0;
 100               		.loc 1 102 0
 101 0032 A0E0      		ldi r26,lo8(0)
 101:main.c        ****             rx_nr_recv=0;
 102               		.loc 1 101 0
 103 0034 E0E0      		ldi r30,lo8(0)
 100:main.c        ****             rx_state = RECEIVING;
 104               		.loc 1 100 0
 105 0036 71E0      		ldi r23,lo8(1)
 106 0038 00C0      		rjmp .L6
 107               	.L8:
 108:main.c        ****         rx_nr_recv++;
 108               		.loc 1 108 0
 109 003a EF5F      		subi r30,lo8(-(1))
 110:main.c        ****         cur_rx |= (rx_in << rx_nr_recv);
 110               		.loc 1 110 0
 111 003c 822F      		mov r24,r18
 112 003e 932F      		mov r25,r19
 113 0040 0E2F      		mov r16,r30
 114 0042 00C0      		rjmp 2f
 115 0044 880F      	1:	lsl r24
 116 0046 991F      		rol r25
 117 0048 0A95      	2:	dec r16
 118 004a 02F4      		brpl 1b
 119 004c A82B      		or r26,r24
 112:main.c        ****         if(rx_nr_recv == 8){
 120               		.loc 1 112 0
 121 004e E830      		cpi r30,lo8(8)
 122 0050 01F4      		brne .L6
 113:main.c        ****             rx_state = STOP;
 123               		.loc 1 113 0
 124 0052 74E0      		ldi r23,lo8(4)
 125 0054 00C0      		rjmp .L6
 126               	.L16:
 118:main.c        ****         if(rx_in){
 127               		.loc 1 118 0
 128 0056 BB23      		tst r27
 129 0058 01F0      		breq .L6
 119:main.c        ****             rx[cur_rx_pos] = cur_rx;
 130               		.loc 1 119 0
 131 005a A883      		st Y,r26
 120:main.c        ****             rx_state = IDLE;
 132               		.loc 1 120 0
 133 005c 70E0      		ldi r23,lo8(0)
 134               	.L6:
 127:main.c        ****     switch (tx_state){
 135               		.loc 1 127 0
 136 005e 6230      		cpi r22,lo8(2)
 137 0060 01F0      		breq .L11
 138 0062 6430      		cpi r22,lo8(4)
 139 0064 01F0      		breq .L12
 140 0066 6623      		tst r22
 141 0068 01F4      		brne .L15
 130:main.c        ****         if(cur_tx_pos != 0) { //if data is waiting
 142               		.loc 1 130 0
 143 006a 5523      		tst r21
 144 006c 01F0      		breq .L15
 133:main.c        ****             tx_nr_sent=0;
 145               		.loc 1 133 0
 146 006e F0E0      		ldi r31,lo8(0)
 132:main.c        ****             tx_state = SENDING;
 147               		.loc 1 132 0
 148 0070 62E0      		ldi r22,lo8(2)
 149 0072 00C0      		rjmp .L15
 150               	.L11:
 141:main.c        ****         tx_nr_sent++;
 151               		.loc 1 141 0
 152 0074 FF5F      		subi r31,lo8(-(1))
 145:main.c        ****         if(tx_nr_sent == 8){
 153               		.loc 1 145 0
 154 0076 F830      		cpi r31,lo8(8)
 155 0078 01F4      		brne .L15
 146:main.c        ****             tx_state = STOP;
 156               		.loc 1 146 0
 157 007a 64E0      		ldi r22,lo8(4)
 158 007c 00C0      		rjmp .L15
 159               	.LBE5:
 160               	.LBE4:
 161               		.cfi_endproc
 162               	.LFE6:
 164               		.text
 165               	.global	__vector_1
 167               	__vector_1:
 168               	.LFB9:
 192:main.c        **** 
 193:main.c        **** 
 194:main.c        **** 
 195:main.c        **** 
 196:main.c        **** 
 197:main.c        **** 
 198:main.c        **** //=====================================
 199:main.c        **** //INTERRUPT HANDLERS
 200:main.c        **** //=====================================
 201:main.c        **** 
 202:main.c        **** //Warning, interrupts are ISR_NAKED to reduce jitter in the start
 203:main.c        **** //of the cap measurement and UART sample times. Be careful when
 204:main.c        **** //changing
 205:main.c        **** 
 206:main.c        **** //external interrupt
 207:main.c        **** ISR(INT0_vect,ISR_NAKED){
 169               		.loc 1 207 0
 170               		.cfi_startproc
 171               	/* prologue: naked */
 172               	/* frame size = 0 */
 173               	/* stack size = 0 */
 174               	.L__stack_usage = 0
 208:main.c        ****     //enter interrupt
 209:main.c        ****     asm("push r16");
 175               		.loc 1 209 0
 176               	/* #APP */
 177               	 ;  209 "main.c" 1
 178 001a 0F93      		push r16
 179               	 ;  0 "" 2
 210:main.c        ****     asm("in r16,__SREG__");
 180               		.loc 1 210 0
 181               	 ;  210 "main.c" 1
 182 001c 0FB7      		in r16,__SREG__
 183               	 ;  0 "" 2
 211:main.c        ****     asm("push r24");
 184               		.loc 1 211 0
 185               	 ;  211 "main.c" 1
 186 001e 8F93      		push r24
 187               	 ;  0 "" 2
 212:main.c        ****     asm("push r25");
 188               		.loc 1 212 0
 189               	 ;  212 "main.c" 1
 190 0020 9F93      		push r25
 191               	 ;  0 "" 2
 213:main.c        ****     //OCR0A = TCNT0+UART_HALF_BIT_TIME;
 214:main.c        ****     asm("in r24,40");
 192               		.loc 1 214 0
 193               	 ;  214 "main.c" 1
 194 0022 88B5      		in r24,40
 195               	 ;  0 "" 2
 215:main.c        ****     asm("in r25,41");
 196               		.loc 1 215 0
 197               	 ;  215 "main.c" 1
 198 0024 99B5      		in r25,41
 199               	 ;  0 "" 2
 216:main.c        ****     asm("subi r24,lo8(-(194))");
 200               		.loc 1 216 0
 201               	 ;  216 "main.c" 1
 202 0026 8E53      		subi r24,lo8(-(194))
 203               	 ;  0 "" 2
 217:main.c        ****     asm("sbci r25,hi8(-(194))");
 204               		.loc 1 217 0
 205               	 ;  217 "main.c" 1
 206 0028 9F4F      		sbci r25,hi8(-(194))
 207               	 ;  0 "" 2
 218:main.c        ****     asm("out 39,r25");
 208               		.loc 1 218 0
 209               	 ;  218 "main.c" 1
 210 002a 97BD      		out 39,r25
 211               	 ;  0 "" 2
 219:main.c        ****     asm("out 38,r24");
 212               		.loc 1 219 0
 213               	 ;  219 "main.c" 1
 214 002c 86BD      		out 38,r24
 215               	 ;  0 "" 2
 220:main.c        ****     //EIMSK = 0x00;
 221:main.c        ****     asm("ldi r24,lo8(0)");
 216               		.loc 1 221 0
 217               	 ;  221 "main.c" 1
 218 002e 80E0      		ldi r24,lo8(0)
 219               	 ;  0 "" 2
 222:main.c        ****     asm("out 19,r24");
 220               		.loc 1 222 0
 221               	 ;  222 "main.c" 1
 222 0030 83BB      		out 19,r24
 223               	 ;  0 "" 2
 223:main.c        ****     //exit interrupt
 224:main.c        ****     asm("pop r25");
 224               		.loc 1 224 0
 225               	 ;  224 "main.c" 1
 226 0032 9F91      		pop r25
 227               	 ;  0 "" 2
 225:main.c        ****     asm("pop r24");
 228               		.loc 1 225 0
 229               	 ;  225 "main.c" 1
 230 0034 8F91      		pop r24
 231               	 ;  0 "" 2
 226:main.c        ****     asm("out __SREG__,r16");
 232               		.loc 1 226 0
 233               	 ;  226 "main.c" 1
 234 0036 0FBF      		out __SREG__,r16
 235               	 ;  0 "" 2
 227:main.c        ****     asm("pop r16");
 236               		.loc 1 227 0
 237               	 ;  227 "main.c" 1
 238 0038 0F91      		pop r16
 239               	 ;  0 "" 2
 228:main.c        ****     asm("reti");
 240               		.loc 1 228 0
 241               	 ;  228 "main.c" 1
 242 003a 1895      		reti
 243               	 ;  0 "" 2
 244               	/* epilogue start */
 229:main.c        **** }
 245               		.loc 1 229 0
 246               	/* #NOAPP */
 247               		.cfi_endproc
 248               	.LFE9:
 250               	.global	__vector_4
 252               	__vector_4:
 253               	.LFB10:
 230:main.c        **** 
 231:main.c        **** 
 232:main.c        **** //TIM0 overflow handler, measurement start
 233:main.c        **** ISR(TIM0_OVF_vect, ISR_NAKED){
 254               		.loc 1 233 0
 255               		.cfi_startproc
 256               	/* prologue: naked */
 257               	/* frame size = 0 */
 258               	/* stack size = 0 */
 259               	.L__stack_usage = 0
 234:main.c        ****     //set cap_touch pin to input pin to input
 235:main.c        ****     //DDRB = (1 << CAP_TOUCH_PIN);
 236:main.c        ****     asm("push r24");
 260               		.loc 1 236 0
 261               	/* #APP */
 262               	 ;  236 "main.c" 1
 263 003c 8F93      		push r24
 264               	 ;  0 "" 2
 237:main.c        ****     asm("ldi r24,lo8(2)");
 265               		.loc 1 237 0
 266               	 ;  237 "main.c" 1
 267 003e 82E0      		ldi r24,lo8(2)
 268               	 ;  0 "" 2
 238:main.c        ****     asm("out 1,r24");
 269               		.loc 1 238 0
 270               	 ;  238 "main.c" 1
 271 0040 81B9      		out 1,r24
 272               	 ;  0 "" 2
 239:main.c        ****     asm("pop r24");
 273               		.loc 1 239 0
 274               	 ;  239 "main.c" 1
 275 0042 8F91      		pop r24
 276               	 ;  0 "" 2
 240:main.c        ****     asm("reti");
 277               		.loc 1 240 0
 278               	 ;  240 "main.c" 1
 279 0044 1895      		reti
 280               	 ;  0 "" 2
 281               	/* epilogue start */
 241:main.c        **** }
 282               		.loc 1 241 0
 283               	/* #NOAPP */
 284               		.cfi_endproc
 285               	.LFE10:
 287               	.global	__vector_6
 289               	__vector_6:
 290               	.LFB11:
 242:main.c        **** 
 243:main.c        **** 
 244:main.c        **** //TIM0 overflow handler
 245:main.c        **** ISR(TIM0_COMPB_vect,ISR_NAKED){
 291               		.loc 1 245 0
 292               		.cfi_startproc
 293               	/* prologue: naked */
 294               	/* frame size = 0 */
 295               	/* stack size = 0 */
 296               	.L__stack_usage = 0
 246:main.c        ****     //only enable OCR0A interrupt
 247:main.c        ****     //TIMSK0 = oc_state;
 248:main.c        ****     asm("push r24");
 297               		.loc 1 248 0
 298               	/* #APP */
 299               	 ;  248 "main.c" 1
 300 0046 8F93      		push r24
 301               	 ;  0 "" 2
 249:main.c        ****     asm("lds r24,ocr_state");
 302               		.loc 1 249 0
 303               	 ;  249 "main.c" 1
 304 0048 80A0      		lds r24,ocr_state
 305               	 ;  0 "" 2
 250:main.c        ****     asm("out 43,r24");
 306               		.loc 1 250 0
 307               	 ;  250 "main.c" 1
 308 004a 8BBD      		out 43,r24
 309               	 ;  0 "" 2
 251:main.c        ****     asm("pop r24");
 310               		.loc 1 251 0
 311               	 ;  251 "main.c" 1
 312 004c 8F91      		pop r24
 313               	 ;  0 "" 2
 252:main.c        ****     asm("reti");
 314               		.loc 1 252 0
 315               	 ;  252 "main.c" 1
 316 004e 1895      		reti
 317               	 ;  0 "" 2
 318               	/* epilogue start */
 253:main.c        **** }
 319               		.loc 1 253 0
 320               	/* #NOAPP */
 321               		.cfi_endproc
 322               	.LFE11:
 324               	.global	__vector_5
 326               	__vector_5:
 327               	.LFB12:
 254:main.c        **** 
 255:main.c        **** 
 256:main.c        **** //OCR0A interrupt handler
 257:main.c        **** ISR(TIM0_COMPA_vect){
 328               		.loc 1 257 0
 329               		.cfi_startproc
 330 0050 1F93      		push r17
 331               	.LCFI0:
 332               		.cfi_def_cfa_offset 3
 333               		.cfi_offset 17, -2
 334 0052 0F93      		push r16
 335               	.LCFI1:
 336               		.cfi_def_cfa_offset 4
 337               		.cfi_offset 16, -3
 338 0054 0FB7      		in r16,__SREG__
 339 0056 0F93      		push r16
 340 0058 10E0      		ldi __zero_reg__,lo8(0)
 341 005a 8F93      		push r24
 342               	.LCFI2:
 343               		.cfi_def_cfa_offset 5
 344               		.cfi_offset 24, -4
 345 005c 9F93      		push r25
 346               	.LCFI3:
 347               		.cfi_def_cfa_offset 6
 348               		.cfi_offset 25, -5
 349               	/* prologue: Signal */
 350               	/* frame size = 0 */
 351               	/* stack size = 5 */
 352               	.L__stack_usage = 5
 258:main.c        **** 
 259:main.c        ****     //update OCR0A
 260:main.c        ****     OCR0A += UART_BIT_TIME - ISR_OFFSET;
 353               		.loc 1 260 0
 354 005e 86B5      		in r24,38-0
 355 0060 97B5      		in r25,38+1-0
 356 0062 8D56      		subi r24,lo8(-(403))
 357 0064 9E4F      		sbci r25,hi8(-(403))
 358 0066 97BD      		out 38+1-0,r25
 359 0068 86BD      		out 38-0,r24
 261:main.c        ****     //sample input
 262:main.c        ****     cur_rx |= ((PINB >> 2) & 0x01) << 1;
 360               		.loc 1 262 0
 361 006a 80B1      		in r24,0-0
 362 006c 8695      		lsr r24
 363 006e 8695      		lsr r24
 364 0070 90E0      		ldi r25,lo8(0)
 365 0072 8170      		andi r24,lo8(1)
 366 0074 9070      		andi r25,hi8(1)
 367 0076 880F      		lsl r24
 368 0078 991F      		rol r25
 369 007a 90A0      		lds r25,cur_rx
 370 007c 982B      		or r25,r24
 371 007e 90A8      		sts cur_rx,r25
 263:main.c        ****     //set output
 264:main.c        ****     PINB |= cur_tx;
 372               		.loc 1 264 0
 373 0080 80B1      		in r24,0-0
 374 0082 90A0      		lds r25,cur_tx
 375 0084 892B      		or r24,r25
 376 0086 80B9      		out 0-0,r24
 265:main.c        ****     //increment count
 266:main.c        ****     uart_cnt++;
 377               		.loc 1 266 0
 378 0088 80A0      		lds r24,uart_cnt
 379 008a 8F5F      		subi r24,lo8(-(1))
 380 008c 80A8      		sts uart_cnt,r24
 267:main.c        ****     if(uart_cnt > 9){
 381               		.loc 1 267 0
 382 008e 8A30      		cpi r24,lo8(10)
 383 0090 00F0      		brlo .L20
 268:main.c        ****         //disable OCR0A interrupt until processed
 269:main.c        ****         TIMSK0 &= ~(1 << OCIE0A);
 384               		.loc 1 269 0
 385 0092 8BB5      		in r24,43-0
 386 0094 8D7F      		andi r24,lo8(-3)
 387 0096 8BBD      		out 43-0,r24
 270:main.c        ****         ocr_state = 0x00;
 388               		.loc 1 270 0
 389 0098 10A8      		sts ocr_state,__zero_reg__
 390               	.L20:
 391               	/* epilogue start */
 271:main.c        ****     }
 272:main.c        **** 
 273:main.c        **** }
 392               		.loc 1 273 0
 393 009a 9F91      		pop r25
 394 009c 8F91      		pop r24
 395 009e 0F91      		pop r16
 396 00a0 0FBF      		out __SREG__,r16
 397 00a2 0F91      		pop r16
 398 00a4 1F91      		pop r17
 399 00a6 1895      		reti
 400               		.cfi_endproc
 401               	.LFE12:
 403               		.comm uart_cnt,1,1
 404               		.comm cur_tx_pos,1,1
 405               		.comm cur_rx_pos,1,1
 406               		.comm tx_nr_sent,1,1
 407               		.comm rx_nr_recv,1,1
 408               		.comm tx_out,1,1
 409               		.comm cur_tx,1,1
 410               		.comm cur_rx,1,1
 411               		.comm rx_in,1,1
 412               		.comm bit_nr,1,1
 413               		.comm ocr_state,1,1
 414               		.comm tx_state,1,1
 415               		.comm rx_state,1,1
 416               		.comm rx,4,1
 417               		.comm tx,4,1
 418               		.comm sample_state,1,1
 419               		.comm cur_meas,2,1
 420               	.Letext0:
 421               		.file 2 "/opt/cross/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccaDC1j0.s:2      *ABS*:000000000000003f __SREG__
     /tmp/ccaDC1j0.s:3      *ABS*:000000000000003e __SP_H__
     /tmp/ccaDC1j0.s:4      *ABS*:000000000000003d __SP_L__
     /tmp/ccaDC1j0.s:5      *ABS*:000000000000003c __CCP__
     /tmp/ccaDC1j0.s:6      *ABS*:0000000000000010 __tmp_reg__
     /tmp/ccaDC1j0.s:7      *ABS*:0000000000000011 __zero_reg__
     /tmp/ccaDC1j0.s:15     .text:0000000000000000 init
                            *COM*:0000000000000001 sample_state
     /tmp/ccaDC1j0.s:53     .text.startup:0000000000000000 main
                            *COM*:0000000000000001 rx_in
                            *COM*:0000000000000001 cur_rx_pos
                            *COM*:0000000000000001 cur_tx_pos
                            *COM*:0000000000000001 rx_state
                            *COM*:0000000000000001 rx_nr_recv
                            *COM*:0000000000000001 cur_rx
                            *COM*:0000000000000001 tx_state
                            *COM*:0000000000000001 tx_nr_sent
                            *COM*:0000000000000004 rx
     /tmp/ccaDC1j0.s:167    .text:000000000000001a __vector_1
     /tmp/ccaDC1j0.s:252    .text:000000000000003c __vector_4
     /tmp/ccaDC1j0.s:289    .text:0000000000000046 __vector_6
                            *COM*:0000000000000001 ocr_state
     /tmp/ccaDC1j0.s:326    .text:0000000000000050 __vector_5
                            *COM*:0000000000000001 cur_tx
                            *COM*:0000000000000001 uart_cnt
                            *COM*:0000000000000001 tx_out
                            *COM*:0000000000000001 bit_nr
                            *COM*:0000000000000004 tx
                            *COM*:0000000000000002 cur_meas

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
