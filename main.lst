   1               		.file	"main.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x3c
   6               	__tmp_reg__ = 16
   7               	__zero_reg__ = 17
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  10               		.text
  11               	.Ltext0:
  12               		.cfi_sections	.debug_frame
  13               	.global	init
  15               	init:
  16               	.LFB8:
  17               		.file 1 "main.c"
   1:main.c        **** #include <util/delay.h>
   2:main.c        **** #include <avr/io.h>
   3:main.c        **** #include <avr/interrupt.h>
   4:main.c        **** 
   5:main.c        **** #define TRUE (1)
   6:main.c        **** #define FALSE (0)
   7:main.c        **** #define TIM_OCR_START ((uint16_t)208)
   8:main.c        **** #define NEW_SAMPLE (0xFF)
   9:main.c        **** #define OLD_SAMPLE (0x00)
  10:main.c        **** #define CAP_TOUCH_PIN (PIN1) //TODO: set proper pin
  11:main.c        **** //next sample instant 1/19200 = 52us =~ 417 tim-ticks @ 8MHz
  12:main.c        **** #define OCR_INCREMENT ((uint16_t)417)
  13:main.c        **** 
  14:main.c        **** 
  15:main.c        **** void init(void);
  16:main.c        **** 
  17:main.c        **** 
  18:main.c        **** uint16_t cur_meas;
  19:main.c        **** uint8_t sample_state;
  20:main.c        **** 
  21:main.c        **** typedef enum uart_state_t {
  22:main.c        ****     IDLE,
  23:main.c        ****     RECEIVING,
  24:main.c        ****     SENDING,
  25:main.c        ****     START,
  26:main.c        ****     STOP
  27:main.c        **** } uart_state_t;
  28:main.c        **** 
  29:main.c        **** #define UART_BIT_TIME  ((uint16_t)417) //number of clock ticks @8MHz per bit
  30:main.c        **** #define UART_HALF_BIT_TIME  (UART_BIT_TIME / 2) //number of clock ticks @8MHz per bit
  31:main.c        **** #define UART_BUFF_SIZE (4)
  32:main.c        **** #define UART_RX_BIT    (PB0)
  33:main.c        **** #define UART_TX_BIT    (PB1)
  34:main.c        **** #define UART_RX_PORTx  (PORTB)
  35:main.c        **** #define UART_TX_PORTx  (PORTB)
  36:main.c        **** #define UART_RX_PINx   (PINB)
  37:main.c        **** #define UART_TX_PINx   (PINB)
  38:main.c        **** 
  39:main.c        **** #define HIGH (0xFF)
  40:main.c        **** #define LOW  (0x00)
  41:main.c        **** 
  42:main.c        **** #define UART_SET_START(port,pin) (port &= ~(1<<pin))
  43:main.c        **** #define UART_SET_STOP(port,pin)  (port |= (1<<pin))
  44:main.c        **** #define UART_GET_START(port,pin) (~port & (1<<pin))
  45:main.c        **** 
  46:main.c        **** //uart buffers
  47:main.c        **** //TODO: probably not needed
  48:main.c        **** uint8_t tx[UART_BUFF_SIZE];
  49:main.c        **** uint8_t rx[UART_BUFF_SIZE];
  50:main.c        **** 
  51:main.c        **** uart_state_t rx_state;
  52:main.c        **** uart_state_t tx_state;
  53:main.c        **** 
  54:main.c        **** uint8_t bit_nr;
  55:main.c        **** uint8_t rx_in;
  56:main.c        **** uint8_t cur_rx;
  57:main.c        **** uint8_t cur_tx;
  58:main.c        **** uint8_t tx_out;
  59:main.c        **** uint8_t rx_nr_recv;
  60:main.c        **** uint8_t tx_nr_sent;
  61:main.c        **** uint8_t cur_rx_pos;
  62:main.c        **** uint8_t cur_tx_pos;
  63:main.c        **** 
  64:main.c        **** 
  65:main.c        **** 
  66:main.c        **** 
  67:main.c        **** static inline void handle_uart_io(void);
  68:main.c        **** 
  69:main.c        **** int main(void) {
  70:main.c        **** 
  71:main.c        ****   init();
  72:main.c        **** 
  73:main.c        ****   while(TRUE){
  74:main.c        **** 
  75:main.c        ****       handle_uart_io();
  76:main.c        **** 
  77:main.c        **** 
  78:main.c        **** 
  79:main.c        **** 
  80:main.c        ****   }
  81:main.c        **** 
  82:main.c        ****   return 0;
  83:main.c        **** }
  84:main.c        **** 
  85:main.c        **** 
  86:main.c        **** static inline void handle_uart_io(void){
  87:main.c        **** 
  88:main.c        ****     //TODO: error checking here (has the sampling interrupt occured?)
  89:main.c        **** 
  90:main.c        ****     //add sample to state, if byte is complete, store in buffer
  91:main.c        **** 
  92:main.c        ****     switch (rx_state){
  93:main.c        **** 
  94:main.c        ****     case IDLE:
  95:main.c        ****         if(rx_in == 0) { //if 0 was received
  96:main.c        ****             rx_state = RECEIVING;
  97:main.c        ****             rx_nr_recv=0;
  98:main.c        ****             cur_rx = 0;
  99:main.c        ****         }
 100:main.c        ****         break;
 101:main.c        **** 
 102:main.c        ****     case RECEIVING :
 103:main.c        ****         //increment number received bits
 104:main.c        ****         rx_nr_recv++;
 105:main.c        ****         //store received bit
 106:main.c        ****         cur_rx |= (rx_in << rx_nr_recv);
 107:main.c        ****         //check if full byte is received
 108:main.c        ****         if(rx_nr_recv == 8){
 109:main.c        ****             rx_state = STOP;
 110:main.c        ****         }
 111:main.c        ****         break;
 112:main.c        **** 
 113:main.c        ****     case STOP :
 114:main.c        ****         if(rx_in){
 115:main.c        ****             rx[cur_rx_pos] = cur_rx;
 116:main.c        ****             rx_state = IDLE;
 117:main.c        ****         }
 118:main.c        ****         break;
 119:main.c        ****     }
 120:main.c        **** 
 121:main.c        **** 
 122:main.c        ****     //handle TX
 123:main.c        ****     switch (tx_state){
 124:main.c        **** 
 125:main.c        ****     case IDLE:
 126:main.c        ****         if(cur_tx_pos != 0) { //if data is waiting
 127:main.c        ****             tx_out = LOW;
 128:main.c        ****             tx_state = SENDING;
 129:main.c        ****             tx_nr_sent=0;
 130:main.c        ****         } else {
 131:main.c        ****             tx_out = HIGH;
 132:main.c        ****         }
 133:main.c        ****         break;
 134:main.c        **** 
 135:main.c        ****     case SENDING :
 136:main.c        ****         //increment number received bits
 137:main.c        ****         tx_nr_sent++;
 138:main.c        ****         //store received bit
 139:main.c        ****         tx_out |= (cur_tx >> tx_nr_sent) & (0x01);
 140:main.c        ****         //check if full byte is received
 141:main.c        ****         if(tx_nr_sent == 8){
 142:main.c        ****             tx_state = STOP;
 143:main.c        ****         }
 144:main.c        ****         break;
 145:main.c        **** 
 146:main.c        ****     case STOP :
 147:main.c        ****         tx_out = HIGH;
 148:main.c        ****         tx_state = IDLE;
 149:main.c        ****         break;
 150:main.c        ****     }
 151:main.c        **** 
 152:main.c        ****     //determine new output bit
 153:main.c        ****         //if in progress, continue
 154:main.c        ****         //if not in progress, but byte in buffer, start
 155:main.c        ****         //if neither, send 1;
 156:main.c        **** 
 157:main.c        **** 
 158:main.c        **** }
 159:main.c        **** 
 160:main.c        **** 
 161:main.c        **** void init(void){
  18               		.loc 1 161 0
  19               		.cfi_startproc
  20               	/* prologue: function */
  21               	/* frame size = 0 */
  22               	/* stack size = 0 */
  23               	.L__stack_usage = 0
 162:main.c        **** 
 163:main.c        ****     //set clock to 8Mhz, no prescaler, factory calibration
 164:main.c        ****     CLKMSR = 0x00;
  24               		.loc 1 164 0
  25 0000 17BF      		out 55-0,__zero_reg__
 165:main.c        ****     OSCCAL = 0x00;
  26               		.loc 1 165 0
  27 0002 19BF      		out 57-0,__zero_reg__
 166:main.c        ****     CLKPSR = 0x00;
  28               		.loc 1 166 0
  29 0004 16BF      		out 54-0,__zero_reg__
 167:main.c        **** 
 168:main.c        ****     //set timer to CTC mode, no output compare, no prescaler
 169:main.c        ****     //reset on OCROB = floor(65536 / OCR_INCREMENT) * OCR_INCREMEN
 170:main.c        ****     //interrupt on OVF and OCIE0A
 171:main.c        ****     TCCR0A = 0x00;
  30               		.loc 1 171 0
  31 0006 1EBD      		out 46-0,__zero_reg__
 172:main.c        ****     TCCR0B = 0x00; //leave timer disabled for now (1<<CS00);
  32               		.loc 1 172 0
  33 0008 1DBD      		out 45-0,__zero_reg__
 173:main.c        ****     TIMSK0 = (1<<TOIE0) | (1<<OCIE0A) | (1<<OCIE0B);
  34               		.loc 1 173 0
  35 000a 87E0      		ldi r24,lo8(7)
  36 000c 8BBD      		out 43-0,r24
 174:main.c        ****     //set first compare value to 1/19200/2 = 26us = 208 tim-ticks @ 8MHz
 175:main.c        ****     //TODO: verify 16 bit access
 176:main.c        ****     OCR0A = TIM_OCR_START;
  37               		.loc 1 176 0
  38 000e 80ED      		ldi r24,lo8(208)
  39 0010 90E0      		ldi r25,hi8(208)
  40 0012 97BD      		out 38+1-0,r25
  41 0014 86BD      		out 38-0,r24
 177:main.c        **** 
 178:main.c        **** 
 179:main.c        ****     //GPIO init
 180:main.c        ****     //set led and touch to output
 181:main.c        ****     //set one pin to output for uart
 182:main.c        ****     //the other to input with pullup for uart
 183:main.c        **** 
 184:main.c        ****     //set sample state to old
 185:main.c        ****     sample_state = OLD_SAMPLE;
  42               		.loc 1 185 0
  43 0016 10A8      		sts sample_state,__zero_reg__
  44               	/* epilogue start */
 186:main.c        **** 
 187:main.c        **** }
  45               		.loc 1 187 0
  46 0018 0895      		ret
  47               		.cfi_endproc
  48               	.LFE8:
  50               		.section	.text.startup,"ax",@progbits
  51               	.global	main
  53               	main:
  54               	.LFB6:
  69:main.c        **** int main(void) {
  55               		.loc 1 69 0
  56               		.cfi_startproc
  57               	/* prologue: function */
  58               	/* frame size = 0 */
  59               	/* stack size = 0 */
  60               	.L__stack_usage = 0
  71:main.c        ****   init();
  61               		.loc 1 71 0
  62 0000 00D0      		rcall init
  63               	.LBB4:
  64               	.LBB5:
 114:main.c        ****         if(rx_in){
  65               		.loc 1 114 0
  66 0002 B0A0      		lds r27,rx_in
 115:main.c        ****             rx[cur_rx_pos] = cur_rx;
  67               		.loc 1 115 0
  68 0004 C0A0      		lds r28,cur_rx_pos
  69 0006 D0E0      		ldi r29,lo8(0)
 106:main.c        ****         cur_rx |= (rx_in << rx_nr_recv);
  70               		.loc 1 106 0
  71 0008 2B2F      		mov r18,r27
  72 000a 30E0      		ldi r19,lo8(0)
 126:main.c        ****         if(cur_tx_pos != 0) { //if data is waiting
  73               		.loc 1 126 0
  74 000c 50A0      		lds r21,cur_tx_pos
  75 000e 70A0      		lds r23,rx_state
  76 0010 E0A0      		lds r30,rx_nr_recv
  77 0012 A0A0      		lds r26,cur_rx
  78 0014 60A0      		lds r22,tx_state
  79 0016 F0A0      		lds r31,tx_nr_sent
 115:main.c        ****             rx[cur_rx_pos] = cur_rx;
  80               		.loc 1 115 0
  81 0018 C050      		subi r28,lo8(-(rx))
  82 001a D040      		sbci r29,hi8(-(rx))
  83 001c 00C0      		rjmp .L15
  84               	.L12:
 148:main.c        ****         tx_state = IDLE;
  85               		.loc 1 148 0
  86 001e 60E0      		ldi r22,lo8(0)
  87               	.L15:
  92:main.c        ****     switch (rx_state){
  88               		.loc 1 92 0 discriminator 1
  89 0020 7130      		cpi r23,lo8(1)
  90 0022 01F0      		breq .L8
  91 0024 7130      		cpi r23,lo8(1)
  92 0026 00F0      		brlo .L7
  93 0028 7430      		cpi r23,lo8(4)
  94 002a 01F4      		brne .L6
  95 002c 00C0      		rjmp .L16
  96               	.L7:
  95:main.c        ****         if(rx_in == 0) { //if 0 was received
  97               		.loc 1 95 0
  98 002e BB23      		tst r27
  99 0030 01F4      		brne .L6
  98:main.c        ****             cur_rx = 0;
 100               		.loc 1 98 0
 101 0032 A0E0      		ldi r26,lo8(0)
  97:main.c        ****             rx_nr_recv=0;
 102               		.loc 1 97 0
 103 0034 E0E0      		ldi r30,lo8(0)
  96:main.c        ****             rx_state = RECEIVING;
 104               		.loc 1 96 0
 105 0036 71E0      		ldi r23,lo8(1)
 106 0038 00C0      		rjmp .L6
 107               	.L8:
 104:main.c        ****         rx_nr_recv++;
 108               		.loc 1 104 0
 109 003a EF5F      		subi r30,lo8(-(1))
 106:main.c        ****         cur_rx |= (rx_in << rx_nr_recv);
 110               		.loc 1 106 0
 111 003c 822F      		mov r24,r18
 112 003e 932F      		mov r25,r19
 113 0040 0E2F      		mov r16,r30
 114 0042 00C0      		rjmp 2f
 115 0044 880F      	1:	lsl r24
 116 0046 991F      		rol r25
 117 0048 0A95      	2:	dec r16
 118 004a 02F4      		brpl 1b
 119 004c A82B      		or r26,r24
 108:main.c        ****         if(rx_nr_recv == 8){
 120               		.loc 1 108 0
 121 004e E830      		cpi r30,lo8(8)
 122 0050 01F4      		brne .L6
 109:main.c        ****             rx_state = STOP;
 123               		.loc 1 109 0
 124 0052 74E0      		ldi r23,lo8(4)
 125 0054 00C0      		rjmp .L6
 126               	.L16:
 114:main.c        ****         if(rx_in){
 127               		.loc 1 114 0
 128 0056 BB23      		tst r27
 129 0058 01F0      		breq .L6
 115:main.c        ****             rx[cur_rx_pos] = cur_rx;
 130               		.loc 1 115 0
 131 005a A883      		st Y,r26
 116:main.c        ****             rx_state = IDLE;
 132               		.loc 1 116 0
 133 005c 70E0      		ldi r23,lo8(0)
 134               	.L6:
 123:main.c        ****     switch (tx_state){
 135               		.loc 1 123 0
 136 005e 6230      		cpi r22,lo8(2)
 137 0060 01F0      		breq .L11
 138 0062 6430      		cpi r22,lo8(4)
 139 0064 01F0      		breq .L12
 140 0066 6623      		tst r22
 141 0068 01F4      		brne .L15
 126:main.c        ****         if(cur_tx_pos != 0) { //if data is waiting
 142               		.loc 1 126 0
 143 006a 5523      		tst r21
 144 006c 01F0      		breq .L15
 129:main.c        ****             tx_nr_sent=0;
 145               		.loc 1 129 0
 146 006e F0E0      		ldi r31,lo8(0)
 128:main.c        ****             tx_state = SENDING;
 147               		.loc 1 128 0
 148 0070 62E0      		ldi r22,lo8(2)
 149 0072 00C0      		rjmp .L15
 150               	.L11:
 137:main.c        ****         tx_nr_sent++;
 151               		.loc 1 137 0
 152 0074 FF5F      		subi r31,lo8(-(1))
 141:main.c        ****         if(tx_nr_sent == 8){
 153               		.loc 1 141 0
 154 0076 F830      		cpi r31,lo8(8)
 155 0078 01F4      		brne .L15
 142:main.c        ****             tx_state = STOP;
 156               		.loc 1 142 0
 157 007a 64E0      		ldi r22,lo8(4)
 158 007c 00C0      		rjmp .L15
 159               	.LBE5:
 160               	.LBE4:
 161               		.cfi_endproc
 162               	.LFE6:
 164               		.text
 165               	.global	__vector_1
 167               	__vector_1:
 168               	.LFB9:
 188:main.c        **** 
 189:main.c        **** ////external interrupt -> store timer value
 190:main.c        **** //ISR(PCINT0_vect,ISR_NAKED)
 191:main.c        **** //{
 192:main.c        **** //   //cur_meas = TCNT0; TCNT0 = 0x28 = 40
 193:main.c        **** //   asm("push r24");
 194:main.c        **** //   asm("push r25");
 195:main.c        **** //   asm("in r24,40");
 196:main.c        **** //   asm("in r25,41");
 197:main.c        **** //   asm("sts cur_meas+1,r25");
 198:main.c        **** //   asm("sts cur_meas,r24");
 199:main.c        **** //   asm("pop r25");
 200:main.c        **** //   asm("pop r24");
 201:main.c        **** //   asm("reti");
 202:main.c        **** //}
 203:main.c        **** 
 204:main.c        **** //external interrupt -> store timer value
 205:main.c        **** ISR(INT0_vect){
 169               		.loc 1 205 0
 170               		.cfi_startproc
 171 001a 1F93      		push r17
 172               	.LCFI0:
 173               		.cfi_def_cfa_offset 3
 174               		.cfi_offset 17, -2
 175 001c 0F93      		push r16
 176               	.LCFI1:
 177               		.cfi_def_cfa_offset 4
 178               		.cfi_offset 16, -3
 179 001e 0FB7      		in r16,__SREG__
 180 0020 0F93      		push r16
 181 0022 10E0      		ldi __zero_reg__,lo8(0)
 182 0024 8F93      		push r24
 183               	.LCFI2:
 184               		.cfi_def_cfa_offset 5
 185               		.cfi_offset 24, -4
 186 0026 9F93      		push r25
 187               	.LCFI3:
 188               		.cfi_def_cfa_offset 6
 189               		.cfi_offset 25, -5
 190               	/* prologue: Signal */
 191               	/* frame size = 0 */
 192               	/* stack size = 5 */
 193               	.L__stack_usage = 5
 206:main.c        ****    OCR0A = TCNT0+UART_HALF_BIT_TIME;
 194               		.loc 1 206 0
 195 0028 88B5      		in r24,40-0
 196 002a 99B5      		in r25,40+1-0
 197 002c 8053      		subi r24,lo8(-(208))
 198 002e 9F4F      		sbci r25,hi8(-(208))
 199 0030 97BD      		out 38+1-0,r25
 200 0032 86BD      		out 38-0,r24
 201               	/* epilogue start */
 207:main.c        ****    //disable EXTI;
 208:main.c        **** }
 202               		.loc 1 208 0
 203 0034 9F91      		pop r25
 204 0036 8F91      		pop r24
 205 0038 0F91      		pop r16
 206 003a 0FBF      		out __SREG__,r16
 207 003c 0F91      		pop r16
 208 003e 1F91      		pop r17
 209 0040 1895      		reti
 210               		.cfi_endproc
 211               	.LFE9:
 213               	.global	__vector_4
 215               	__vector_4:
 216               	.LFB10:
 209:main.c        **** 
 210:main.c        **** 
 211:main.c        **** //TIM0 overflow handler, measurement start (don't use registers, so no loads..)
 212:main.c        **** ISR(TIM0_OVF_vect, ISR_NAKED){
 217               		.loc 1 212 0
 218               		.cfi_startproc
 219               	/* prologue: naked */
 220               	/* frame size = 0 */
 221               	/* stack size = 0 */
 222               	.L__stack_usage = 0
 213:main.c        ****     //set cap_touch pin to input pin to input
 214:main.c        ****     //DDRB = (1 << CAP_TOUCH_PIN);
 215:main.c        ****     asm("push r24");
 223               		.loc 1 215 0
 224               	/* #APP */
 225               	 ;  215 "main.c" 1
 226 0042 8F93      		push r24
 227               	 ;  0 "" 2
 216:main.c        ****     asm("ldi r24,lo8(2)");
 228               		.loc 1 216 0
 229               	 ;  216 "main.c" 1
 230 0044 82E0      		ldi r24,lo8(2)
 231               	 ;  0 "" 2
 217:main.c        ****     asm("out 1,r24");
 232               		.loc 1 217 0
 233               	 ;  217 "main.c" 1
 234 0046 81B9      		out 1,r24
 235               	 ;  0 "" 2
 218:main.c        ****     asm("pop r24");
 236               		.loc 1 218 0
 237               	 ;  218 "main.c" 1
 238 0048 8F91      		pop r24
 239               	 ;  0 "" 2
 219:main.c        ****     asm("reti");
 240               		.loc 1 219 0
 241               	 ;  219 "main.c" 1
 242 004a 1895      		reti
 243               	 ;  0 "" 2
 244               	/* epilogue start */
 220:main.c        **** }
 245               		.loc 1 220 0
 246               	/* #NOAPP */
 247               		.cfi_endproc
 248               	.LFE10:
 250               	.global	__vector_6
 252               	__vector_6:
 253               	.LFB11:
 221:main.c        **** 
 222:main.c        **** 
 223:main.c        **** //TIM0 overflow handler (don't use registers, so no loads..)
 224:main.c        **** ISR(TIM0_COMPB_vect,ISR_NAKED){
 254               		.loc 1 224 0
 255               		.cfi_startproc
 256               	/* prologue: naked */
 257               	/* frame size = 0 */
 258               	/* stack size = 0 */
 259               	.L__stack_usage = 0
 225:main.c        ****     //only enable OCR0A interrupt
 226:main.c        ****     //TIMSK0 = (1<<OCIE0A);
 227:main.c        ****     asm("push r24");
 260               		.loc 1 227 0
 261               	/* #APP */
 262               	 ;  227 "main.c" 1
 263 004c 8F93      		push r24
 264               	 ;  0 "" 2
 228:main.c        ****     //asm("ldi r24,lo8(2)");
 229:main.c        ****     //asm("out 43,r24");
 230:main.c        ****     TIMSK0 = bit_nr;
 265               		.loc 1 230 0
 266               	/* #NOAPP */
 267 004e 80A0      		lds r24,bit_nr
 268 0050 8BBD      		out 43-0,r24
 231:main.c        ****     asm("pop r24");
 269               		.loc 1 231 0
 270               	/* #APP */
 271               	 ;  231 "main.c" 1
 272 0052 8F91      		pop r24
 273               	 ;  0 "" 2
 232:main.c        ****     asm("reti");
 274               		.loc 1 232 0
 275               	 ;  232 "main.c" 1
 276 0054 1895      		reti
 277               	 ;  0 "" 2
 278               	/* epilogue start */
 233:main.c        **** }
 279               		.loc 1 233 0
 280               	/* #NOAPP */
 281               		.cfi_endproc
 282               	.LFE11:
 284               	.global	__vector_5
 286               	__vector_5:
 287               	.LFB12:
 234:main.c        **** 
 235:main.c        **** 
 236:main.c        **** //OCR0A interrupt handler
 237:main.c        **** ISR(TIM0_COMPA_vect){
 288               		.loc 1 237 0
 289               		.cfi_startproc
 290 0056 1F93      		push r17
 291               	.LCFI4:
 292               		.cfi_def_cfa_offset 3
 293               		.cfi_offset 17, -2
 294 0058 0F93      		push r16
 295               	.LCFI5:
 296               		.cfi_def_cfa_offset 4
 297               		.cfi_offset 16, -3
 298 005a 0FB7      		in r16,__SREG__
 299 005c 0F93      		push r16
 300 005e 10E0      		ldi __zero_reg__,lo8(0)
 301 0060 8F93      		push r24
 302               	.LCFI6:
 303               		.cfi_def_cfa_offset 5
 304               		.cfi_offset 24, -4
 305 0062 9F93      		push r25
 306               	.LCFI7:
 307               		.cfi_def_cfa_offset 6
 308               		.cfi_offset 25, -5
 309               	/* prologue: Signal */
 310               	/* frame size = 0 */
 311               	/* stack size = 5 */
 312               	.L__stack_usage = 5
 238:main.c        **** 
 239:main.c        ****     //store new rx_in value;
 240:main.c        ****     rx_in = UART_RX_PINx & (1 << UART_RX_BIT);
 313               		.loc 1 240 0
 314 0064 80B1      		in r24,0-0
 315 0066 8170      		andi r24,lo8(1)
 316 0068 80A8      		sts rx_in,r24
 241:main.c        ****     //write next output bit
 242:main.c        ****     if(tx_out > 0){
 317               		.loc 1 242 0
 318 006a 80A0      		lds r24,tx_out
 319 006c 8823      		tst r24
 320 006e 01F0      		breq .L21
 243:main.c        ****         UART_TX_PORTx |= (1<<UART_TX_BIT);
 321               		.loc 1 243 0
 322 0070 119A      		sbi 2-0,1
 323 0072 00C0      		rjmp .L22
 324               	.L21:
 244:main.c        ****     } else {
 245:main.c        ****         UART_TX_PORTx &= ~(1<<UART_TX_BIT);
 325               		.loc 1 245 0
 326 0074 1198      		cbi 2-0,1
 327               	.L22:
 246:main.c        ****     }
 247:main.c        ****     //update interrupt compare value
 248:main.c        ****     OCR0A += OCR_INCREMENT;
 328               		.loc 1 248 0
 329 0076 86B5      		in r24,38-0
 330 0078 97B5      		in r25,38+1-0
 331 007a 8F55      		subi r24,lo8(-(417))
 332 007c 9E4F      		sbci r25,hi8(-(417))
 333 007e 97BD      		out 38+1-0,r25
 334 0080 86BD      		out 38-0,r24
 249:main.c        **** 
 250:main.c        **** 
 251:main.c        ****     //enable eternal interrupt
 252:main.c        ****     PCICR |= (1 << PCIE0);
 335               		.loc 1 252 0
 336 0082 909A      		sbi 18-0,0
 337               	/* epilogue start */
 253:main.c        **** }
 338               		.loc 1 253 0
 339 0084 9F91      		pop r25
 340 0086 8F91      		pop r24
 341 0088 0F91      		pop r16
 342 008a 0FBF      		out __SREG__,r16
 343 008c 0F91      		pop r16
 344 008e 1F91      		pop r17
 345 0090 1895      		reti
 346               		.cfi_endproc
 347               	.LFE12:
 349               		.comm cur_tx_pos,1,1
 350               		.comm cur_rx_pos,1,1
 351               		.comm tx_nr_sent,1,1
 352               		.comm rx_nr_recv,1,1
 353               		.comm tx_out,1,1
 354               		.comm cur_tx,1,1
 355               		.comm cur_rx,1,1
 356               		.comm rx_in,1,1
 357               		.comm bit_nr,1,1
 358               		.comm tx_state,1,1
 359               		.comm rx_state,1,1
 360               		.comm rx,4,1
 361               		.comm tx,4,1
 362               		.comm sample_state,1,1
 363               		.comm cur_meas,2,1
 364               	.Letext0:
 365               		.file 2 "/opt/cross/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccQd9XP3.s:2      *ABS*:000000000000003f __SREG__
     /tmp/ccQd9XP3.s:3      *ABS*:000000000000003e __SP_H__
     /tmp/ccQd9XP3.s:4      *ABS*:000000000000003d __SP_L__
     /tmp/ccQd9XP3.s:5      *ABS*:000000000000003c __CCP__
     /tmp/ccQd9XP3.s:6      *ABS*:0000000000000010 __tmp_reg__
     /tmp/ccQd9XP3.s:7      *ABS*:0000000000000011 __zero_reg__
     /tmp/ccQd9XP3.s:15     .text:0000000000000000 init
                            *COM*:0000000000000001 sample_state
     /tmp/ccQd9XP3.s:53     .text.startup:0000000000000000 main
                            *COM*:0000000000000001 rx_in
                            *COM*:0000000000000001 cur_rx_pos
                            *COM*:0000000000000001 cur_tx_pos
                            *COM*:0000000000000001 rx_state
                            *COM*:0000000000000001 rx_nr_recv
                            *COM*:0000000000000001 cur_rx
                            *COM*:0000000000000001 tx_state
                            *COM*:0000000000000001 tx_nr_sent
                            *COM*:0000000000000004 rx
     /tmp/ccQd9XP3.s:167    .text:000000000000001a __vector_1
     /tmp/ccQd9XP3.s:215    .text:0000000000000042 __vector_4
     /tmp/ccQd9XP3.s:252    .text:000000000000004c __vector_6
                            *COM*:0000000000000001 bit_nr
     /tmp/ccQd9XP3.s:286    .text:0000000000000056 __vector_5
                            *COM*:0000000000000001 tx_out
                            *COM*:0000000000000001 cur_tx
                            *COM*:0000000000000004 tx
                            *COM*:0000000000000002 cur_meas

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
