   1               		.file	"main.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x3c
   6               	__tmp_reg__ = 16
   7               	__zero_reg__ = 17
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  10               		.text
  11               	.Ltext0:
  12               		.cfi_sections	.debug_frame
  13               	.global	init
  15               	init:
  16               	.LFB7:
  17               		.file 1 "main.c"
   1:main.c        **** #include <util/delay.h>
   2:main.c        **** #include <avr/io.h>
   3:main.c        **** #include <avr/interrupt.h>
   4:main.c        **** 
   5:main.c        **** #define TRUE (1)
   6:main.c        **** #define FALSE (0)
   7:main.c        **** 
   8:main.c        **** 
   9:main.c        **** 
  10:main.c        **** 
  11:main.c        **** void init(void);
  12:main.c        **** 
  13:main.c        **** 
  14:main.c        **** 
  15:main.c        **** typedef enum state_t {
  16:main.c        **** 
  17:main.c        ****     TAKEN_PASSED    = 0,
  18:main.c        ****     LED_EN          = 1,
  19:main.c        ****     SET_LED_DIRECT  = 2,
  20:main.c        ****     TOUCHED         = 3,
  21:main.c        ****     RESERVED        = 4,
  22:main.c        ****     LED0            = 5,
  23:main.c        ****     LED1            = 6,
  24:main.c        ****     LED2            = 7
  25:main.c        **** 
  26:main.c        **** } state_t;
  27:main.c        **** 
  28:main.c        **** typedef enum msg_t {
  29:main.c        **** 
  30:main.c        ****     MSG_SLOT_TAKEN  = 0,
  31:main.c        ****     MSG_LED_EN      = 1,
  32:main.c        ****     MSG_LED_DIRECT  = 2,
  33:main.c        ****     MSG_IS_TOUCHED  = 3,
  34:main.c        ****     MSG_RESERVED    = 4,
  35:main.c        ****     MSG_LED0        = 5,
  36:main.c        ****     MSG_LED1        = 6,
  37:main.c        ****     MSG_LED2        = 7
  38:main.c        **** 
  39:main.c        **** } msg_t;
  40:main.c        **** 
  41:main.c        **** 
  42:main.c        **** #define DEFAULT_CONFIGURATION (0b10101010) //TODO: change to proper setting
  43:main.c        **** #define WRITE_PROTECT_DISABLE_SIG (0xD8)
  44:main.c        **** 
  45:main.c        **** #define TOUCH_TIMEOUT ((uint16_t)40000) //roughly 4ms @ 8MHz
  46:main.c        **** #define TOUCH_PIN (PIN1) //TODO: set proper pin (change interrupt)
  47:main.c        **** #define LED_PIN   (PIN0)
  48:main.c        **** 
  49:main.c        **** //the number of instructions before INT0 is executed
  50:main.c        **** #define ISR_OFFSET     (4+10) //4 till call, 10 till instruction
  51:main.c        **** 
  52:main.c        **** //next sample instant 1/19200 = 52us =~ 417 tim-ticks @ 8MHz
  53:main.c        **** #define UART_BIT_TIME       ((uint16_t)417) //number of clock ticks @8MHz per bit
  54:main.c        **** 
  55:main.c        **** #define UART_OCR_OFFSET     (4+10) //4 till call, 10 till instruction
  56:main.c        **** #define UART_OCR_INC        ((UART_BIT_TIME / 2)-UART_OCR_OFFSET)
  57:main.c        **** #define UART_HALF_OCR_INC   (UART_BIT_TIME-UART_OCR_OFFSET)
  58:main.c        **** 
  59:main.c        **** #define UART_RX_PIN    (PIN2)
  60:main.c        **** #define UART_TX_PIN    (PIN3)
  61:main.c        **** #define UART_START     (0)
  62:main.c        **** #define UART_STOP      (9)
  63:main.c        **** 
  64:main.c        **** //protocol definitions
  65:main.c        **** #define SLOT_TAKEN_BIT (7)
  66:main.c        **** 
  67:main.c        **** 
  68:main.c        **** //some macro's to avoid stupid mistakes...
  69:main.c        **** #define IS_SET(var,b)   (var & (1 << b))
  70:main.c        **** #define IS_NSET(var,b)   !(var & (1 << b))
  71:main.c        **** #define SET(var,b)      (var |= (1 << b))
  72:main.c        **** #define CLR(var,b)      (var &= ~(1 << b))
  73:main.c        **** #define B(b)            (1 << b)
  74:main.c        **** //TODO: fix somewhat ugly macro...
  75:main.c        **** #define COPY_BIT(src,src_bit,dest,dest_bit) if(IS_SET(src,src_bit)){ SET(dest,dest_bit); } else {  
  76:main.c        **** 
  77:main.c        **** //mask that determina what bits not to cpoy from rx msg
  78:main.c        **** #define CONF_BIT_MASK (B(MSG_SLOT_TAKEN) | B(MSG_RESERVED) | B(MSG_IS_TOUCHED))
  79:main.c        **** #define CONF_LED_MASK (B(LED0) | B(LED1) | B(LED2))
  80:main.c        **** 
  81:main.c        **** 
  82:main.c        **** //multiplier to avoid floating point...
  83:main.c        **** #define FILTER_MAX (1024)
  84:main.c        **** //portion of multiplier that is given to new value (USE POWER OF 2!!)
  85:main.c        **** #define FILTER_NEW (32)
  86:main.c        **** //portion of multiplier that is given to running average
  87:main.c        **** #define FILTER_AVG (FILTER_MAX-FILTER_NEW)
  88:main.c        **** //low pass filter, use sparingly, costly instruction wise
  89:main.c        **** #define TOUCH_FILTER_LP(avg,new) ((uint16_t)(( (((uint32_t)avg)*FILTER_AVG) + (((uint32_t)new)*FILT
  90:main.c        **** #define TOUCH_AVG_INIT (8000)
  91:main.c        **** 
  92:main.c        **** //level above measurement noise level to detect touch
  93:main.c        **** #define TOUCH_THRESHOLD (512)
  94:main.c        **** //number of measurements in a row, that are above threshold needed to trigger touch
  95:main.c        **** #define TOUCH_VALID_CNT (2)
  96:main.c        **** 
  97:main.c        **** 
  98:main.c        **** uint16_t    cur_meas;
  99:main.c        **** uint8_t     cur_conf,cur_touch;
 100:main.c        **** uint8_t     cur_rx,cur_tx,tx_cnt;
 101:main.c        **** uint8_t     state;
 102:main.c        **** uint8_t     led_val;
 103:main.c        **** 
 104:main.c        **** uint8_t     touch_cnt;
 105:main.c        **** uint16_t    touch_new;
 106:main.c        **** uint16_t    touch_avg; //use sparsely on 8-bit machine...
 107:main.c        **** 
 108:main.c        **** 
 109:main.c        **** 
 110:main.c        **** int main(void) {
 111:main.c        **** 
 112:main.c        ****   init();
 113:main.c        **** 
 114:main.c        ****   //uart is only processed at end of each byte,in the interrupt handler
 115:main.c        ****   //this leaves all the other time for processing measurements
 116:main.c        ****   //this allows higher UART speeds
 117:main.c        **** 
 118:main.c        ****   while(TRUE){
 119:main.c        **** 
 120:main.c        ****       //check for touch timeout / process measurement
 121:main.c        ****       if( (TCNT0 >= TOUCH_TIMEOUT)  ) {
 122:main.c        **** 
 123:main.c        ****           //get input capture time, or limit if no capture occured
 124:main.c        ****           touch_new=(IS_SET(TIFR0,ICF0)) ? ICR0 : TOUCH_TIMEOUT;
 125:main.c        ****           //determine new running average
 126:main.c        ****           touch_avg = TOUCH_FILTER_LP(touch_avg,touch_new);
 127:main.c        ****           //compare new measurement to running average
 128:main.c        ****           if(touch_new > (touch_avg + TOUCH_THRESHOLD)){
 129:main.c        ****               touch_cnt++;
 130:main.c        ****               if(touch_cnt >= TOUCH_VALID_CNT){
 131:main.c        ****                   touch_cnt = TOUCH_VALID_CNT; //need for prolonged touch > 1s (avoid overflow)
 132:main.c        ****                   SET(state,TOUCHED);
 133:main.c        ****               }
 134:main.c        ****           } else {
 135:main.c        ****               touch_cnt = 0;
 136:main.c        ****           }
 137:main.c        **** 
 138:main.c        ****           //start new measurement (clear ICF0, set pin to LOW)
 139:main.c        ****           SET(TIFR0,ICF0);
 140:main.c        ****           CLR(PORTB,TOUCH_PIN);
 141:main.c        ****           SET(DDRB,TOUCH_PIN);
 142:main.c        ****       }
 143:main.c        **** 
 144:main.c        ****       //enable or disable led based on system state
 145:main.c        ****       if( IS_SET(state,LED_EN) || (IS_SET(state,SET_LED_DIRECT) && IS_SET(state,TOUCHED)) ){
 146:main.c        ****           //set led pin to output
 147:main.c        ****           SET(DDRB,LED_PIN);
 148:main.c        ****           CLR(PUEB,LED_PIN);
 149:main.c        ****       } else { //turn off led
 150:main.c        ****           //just setting pin to input is enough
 151:main.c        ****           CLR(DDRB,LED_PIN);
 152:main.c        ****           SET(PUEB,LED_PIN);
 153:main.c        ****       }
 154:main.c        **** 
 155:main.c        **** 
 156:main.c        ****   }
 157:main.c        **** 
 158:main.c        ****   //should not reach
 159:main.c        ****   return 0;
 160:main.c        **** }
 161:main.c        **** 
 162:main.c        **** 
 163:main.c        **** void init(void){
  18               		.loc 1 163 0
  19               		.cfi_startproc
  20               	/* prologue: function */
  21               	/* frame size = 0 */
  22               	/* stack size = 0 */
  23               	.L__stack_usage = 0
 164:main.c        **** 
 165:main.c        ****     cli(); //disable interrupts for the time being
  24               		.loc 1 165 0
  25               	/* #APP */
  26               	 ;  165 "main.c" 1
  27 0000 F894      		cli
  28               	 ;  0 "" 2
 166:main.c        **** 
 167:main.c        ****     //set clock to 8Mhz, no prescaler, factory calibration
 168:main.c        ****     CCP = WRITE_PROTECT_DISABLE_SIG;
  29               		.loc 1 168 0
  30               	/* #NOAPP */
  31 0002 88ED      		ldi r24,lo8(-40)
  32 0004 8CBF      		out 60-0,r24
 169:main.c        ****     CLKPSR = 0x00;
  33               		.loc 1 169 0
  34 0006 16BF      		out 54-0,__zero_reg__
 170:main.c        ****     CLKMSR = 0x00;
  35               		.loc 1 170 0
  36 0008 17BF      		out 55-0,__zero_reg__
 171:main.c        **** 
 172:main.c        ****     //GPIO init
 173:main.c        ****     PORTB = B(LED_PIN) | B(UART_TX_PIN);
  37               		.loc 1 173 0
  38 000a 89E0      		ldi r24,lo8(9)
  39 000c 82B9      		out 2-0,r24
 174:main.c        ****     DDRB  = B(LED_PIN) | B(TOUCH_PIN) | B(UART_TX_PIN);
  40               		.loc 1 174 0
  41 000e 8BE0      		ldi r24,lo8(11)
  42 0010 81B9      		out 1-0,r24
 175:main.c        ****     PUEB  = B(UART_RX_PIN);
  43               		.loc 1 175 0
  44 0012 84E0      		ldi r24,lo8(4)
  45 0014 83B9      		out 3-0,r24
 176:main.c        **** 
 177:main.c        ****     //set timer normal mode (0xFFFF top is convenient for UART)
 178:main.c        ****     //disconnect output compare functionality
 179:main.c        ****     //enable input capture noise filter, trigger on rising edge ( 0->1)
 180:main.c        ****     //leave timer disabled for now (no clock source)
 181:main.c        ****     TCCR0A = 0x00;
  46               		.loc 1 181 0
  47 0016 1EBD      		out 46-0,__zero_reg__
 182:main.c        ****     TCCR0B = B(ICNC0) | B(ICES0);
  48               		.loc 1 182 0
  49 0018 80EC      		ldi r24,lo8(-64)
  50 001a 8DBD      		out 45-0,r24
 183:main.c        ****     //disable interrupts and clear timer for now
 184:main.c        ****     TIMSK0 = 0x00;
  51               		.loc 1 184 0
  52 001c 1BBD      		out 43-0,__zero_reg__
 185:main.c        ****     TCNT0  = 0x0000;
  53               		.loc 1 185 0
  54 001e 19BD      		out 40+1-0,__zero_reg__
  55 0020 18BD      		out 40-0,__zero_reg__
 186:main.c        **** 
 187:main.c        ****     //TODO: RSTDISBL bit ...fuse
 188:main.c        ****     touch_avg = TOUCH_AVG_INIT;
  56               		.loc 1 188 0
  57 0022 80E4      		ldi r24,lo8(8000)
  58 0024 9FE1      		ldi r25,hi8(8000)
  59 0026 90A8      		sts touch_avg+1,r25
  60 0028 80A8      		sts touch_avg,r24
 189:main.c        **** 
 190:main.c        ****     //since all interrupts are disabled, cur_rx will be read as first config
 191:main.c        ****     cur_rx = DEFAULT_CONFIGURATION;
  61               		.loc 1 191 0
  62 002a 8AEA      		ldi r24,lo8(-86)
  63 002c 80A8      		sts cur_rx,r24
 192:main.c        ****     //enable ovf interrupt, start the timer and let the magic begin
 193:main.c        ****     SET(TIMSK0,TOIE0);
  64               		.loc 1 193 0
  65 002e 8BB5      		in r24,43-0
  66 0030 8160      		ori r24,lo8(1)
  67 0032 8BBD      		out 43-0,r24
 194:main.c        ****     SET(TCCR0B,CS00);
  68               		.loc 1 194 0
  69 0034 8DB5      		in r24,45-0
  70 0036 8160      		ori r24,lo8(1)
  71 0038 8DBD      		out 45-0,r24
 195:main.c        ****     sei();
  72               		.loc 1 195 0
  73               	/* #APP */
  74               	 ;  195 "main.c" 1
  75 003a 7894      		sei
  76               	 ;  0 "" 2
  77               	/* epilogue start */
 196:main.c        **** 
 197:main.c        **** }
  78               		.loc 1 197 0
  79               	/* #NOAPP */
  80 003c 0895      		ret
  81               		.cfi_endproc
  82               	.LFE7:
  84               		.section	.text.startup,"ax",@progbits
  85               	.global	main
  87               	main:
  88               	.LFB6:
 110:main.c        **** int main(void) {
  89               		.loc 1 110 0
  90               		.cfi_startproc
  91 0000 CF93      		push r28
  92               	.LCFI0:
  93               		.cfi_def_cfa_offset 3
  94               		.cfi_offset 28, -2
  95 0002 DF93      		push r29
  96               	.LCFI1:
  97               		.cfi_def_cfa_offset 4
  98               		.cfi_offset 29, -3
  99 0004 00D0      		rcall .
 100 0006 00D0      		rcall .
 101               	.LCFI2:
 102               		.cfi_def_cfa_offset 8
 103 0008 CDB7      		in r28,__SP_L__
 104 000a DEB7      		in r29,__SP_H__
 105               	.LCFI3:
 106               		.cfi_def_cfa_register 28
 107               	/* prologue: function */
 108               	/* frame size = 4 */
 109               	/* stack size = 6 */
 110               	.L__stack_usage = 6
 112:main.c        ****   init();
 111               		.loc 1 112 0
 112 000c 00D0      		rcall init
 131:main.c        ****                   touch_cnt = TOUCH_VALID_CNT; //need for prolonged touch > 1s (avoid overflow)
 113               		.loc 1 131 0
 114 000e E2E0      		ldi r30,lo8(2)
 115               	.L12:
 121:main.c        ****       if( (TCNT0 >= TOUCH_TIMEOUT)  ) {
 116               		.loc 1 121 0
 117 0010 88B5      		in r24,40-0
 118 0012 99B5      		in r25,40+1-0
 119 0014 4CE9      		ldi r20,hi8(-25536)
 120 0016 8034      		cpi r24,lo8(-25536)
 121 0018 9407      		cpc r25,r20
 122 001a 00F4      		brsh .+2
 123 001c 00C0      		rjmp .L4
 124:main.c        ****           touch_new=(IS_SET(TIFR0,ICF0)) ? ICR0 : TOUCH_TIMEOUT;
 124               		.loc 1 124 0
 125 001e 0AB5      		in __tmp_reg__,42-0
 126 0020 05FF      		sbrs __tmp_reg__,5
 127 0022 00C0      		rjmp .L11
 124:main.c        ****           touch_new=(IS_SET(TIFR0,ICF0)) ? ICR0 : TOUCH_TIMEOUT;
 128               		.loc 1 124 0 is_stmt 0 discriminator 1
 129 0024 22B5      		in r18,34-0
 130 0026 33B5      		in r19,34+1-0
 131 0028 00C0      		rjmp .L5
 132               	.L11:
 124:main.c        ****           touch_new=(IS_SET(TIFR0,ICF0)) ? ICR0 : TOUCH_TIMEOUT;
 133               		.loc 1 124 0
 134 002a 20E4      		ldi r18,lo8(-25536)
 135 002c 3CE9      		ldi r19,hi8(-25536)
 136               	.L5:
 124:main.c        ****           touch_new=(IS_SET(TIFR0,ICF0)) ? ICR0 : TOUCH_TIMEOUT;
 137               		.loc 1 124 0 discriminator 3
 138 002e 30A8      		sts touch_new+1,r19
 139 0030 20A8      		sts touch_new,r18
 126:main.c        ****           touch_avg = TOUCH_FILTER_LP(touch_avg,touch_new);
 140               		.loc 1 126 0 is_stmt 1 discriminator 3
 141 0032 622F      		mov r22,r18
 142 0034 732F      		mov r23,r19
 143 0036 80E0      		ldi r24,lo8(0)
 144 0038 90E0      		ldi r25,hi8(0)
 145 003a CF5F      		subi r28,lo8(-(1))
 146 003c DF4F      		sbci r29,hi8(-(1))
 147 003e 6993      		st Y+,r22
 148 0040 7993      		st Y+,r23
 149 0042 8993      		st Y+,r24
 150 0044 9883      		st Y,r25
 151 0046 C450      		subi r28,lo8(1+3)
 152 0048 D040      		sbci r29,hi8(1+3)
 153 004a 40A0      		lds r20,touch_avg
 154 004c 50A0      		lds r21,touch_avg+1
 155 004e 60E0      		ldi r22,lo8(0)
 156 0050 70E0      		ldi r23,hi8(0)
 157 0052 B72F      		mov r27,r23
 158 0054 A62F      		mov r26,r22
 159 0056 952F      		mov r25,r21
 160 0058 842F      		mov r24,r20
 161 005a F5E0      		ldi r31,5
 162 005c 880F      	1:	lsl r24
 163 005e 991F      		rol r25
 164 0060 AA1F      		rol r26
 165 0062 BB1F      		rol r27
 166 0064 FA95      		dec r31
 167 0066 01F4      		brne 1b
 168 0068 841B      		sub r24,r20
 169 006a 950B      		sbc r25,r21
 170 006c A60B      		sbc r26,r22
 171 006e B70B      		sbc r27,r23
 172 0070 CF5F      		subi r28,lo8(-(1))
 173 0072 DF4F      		sbci r29,hi8(-(1))
 174 0074 4991      		ld r20,Y+
 175 0076 5991      		ld r21,Y+
 176 0078 6991      		ld r22,Y+
 177 007a 7881      		ld r23,Y
 178 007c C450      		subi r28,lo8(1+3)
 179 007e D040      		sbci r29,hi8(1+3)
 180 0080 480F      		add r20,r24
 181 0082 591F      		adc r21,r25
 182 0084 6A1F      		adc r22,r26
 183 0086 7B1F      		adc r23,r27
 184 0088 F5E0      		ldi r31,5
 185 008a 440F      	1:	lsl r20
 186 008c 551F      		rol r21
 187 008e 661F      		rol r22
 188 0090 771F      		rol r23
 189 0092 FA95      		dec r31
 190 0094 01F4      		brne 1b
 191 0096 FAE0      		ldi r31,10
 192 0098 7695      	1:	lsr r23
 193 009a 6795      		ror r22
 194 009c 5795      		ror r21
 195 009e 4795      		ror r20
 196 00a0 FA95      		dec r31
 197 00a2 01F4      		brne 1b
 198 00a4 CF5F      		subi r28,lo8(-(1))
 199 00a6 DF4F      		sbci r29,hi8(-(1))
 200 00a8 4993      		st Y+,r20
 201 00aa 5993      		st Y+,r21
 202 00ac 6993      		st Y+,r22
 203 00ae 7883      		st Y,r23
 204 00b0 C450      		subi r28,lo8(1+3)
 205 00b2 D040      		sbci r29,hi8(1+3)
 206 00b4 50A8      		sts touch_avg+1,r21
 207 00b6 40A8      		sts touch_avg,r20
 128:main.c        ****           if(touch_new > (touch_avg + TOUCH_THRESHOLD)){
 208               		.loc 1 128 0 discriminator 3
 209 00b8 CF5F      		subi r28,lo8(-(1))
 210 00ba DF4F      		sbci r29,hi8(-(1))
 211 00bc 8991      		ld r24,Y+
 212 00be 9881      		ld r25,Y
 213 00c0 C250      		subi r28,lo8(1+1)
 214 00c2 D040      		sbci r29,hi8(1+1)
 215 00c4 8050      		subi r24,lo8(-(512))
 216 00c6 9E4F      		sbci r25,hi8(-(512))
 217 00c8 8217      		cp r24,r18
 218 00ca 9307      		cpc r25,r19
 219 00cc 00F4      		brsh .L6
 129:main.c        ****               touch_cnt++;
 220               		.loc 1 129 0
 221 00ce 80A0      		lds r24,touch_cnt
 222 00d0 8F5F      		subi r24,lo8(-(1))
 223 00d2 80A8      		sts touch_cnt,r24
 130:main.c        ****               if(touch_cnt >= TOUCH_VALID_CNT){
 224               		.loc 1 130 0
 225 00d4 8230      		cpi r24,lo8(2)
 226 00d6 00F0      		brlo .L7
 131:main.c        ****                   touch_cnt = TOUCH_VALID_CNT; //need for prolonged touch > 1s (avoid overflow)
 227               		.loc 1 131 0
 228 00d8 E0A8      		sts touch_cnt,r30
 132:main.c        ****                   SET(state,TOUCHED);
 229               		.loc 1 132 0
 230 00da 80A0      		lds r24,state
 231 00dc 8860      		ori r24,lo8(8)
 232 00de 80A8      		sts state,r24
 233 00e0 00C0      		rjmp .L7
 234               	.L6:
 135:main.c        ****               touch_cnt = 0;
 235               		.loc 1 135 0
 236 00e2 10A8      		sts touch_cnt,__zero_reg__
 237               	.L7:
 139:main.c        ****           SET(TIFR0,ICF0);
 238               		.loc 1 139 0
 239 00e4 8AB5      		in r24,42-0
 240 00e6 8062      		ori r24,lo8(32)
 241 00e8 8ABD      		out 42-0,r24
 140:main.c        ****           CLR(PORTB,TOUCH_PIN);
 242               		.loc 1 140 0
 243 00ea 1198      		cbi 2-0,1
 141:main.c        ****           SET(DDRB,TOUCH_PIN);
 244               		.loc 1 141 0
 245 00ec 099A      		sbi 1-0,1
 246               	.L4:
 145:main.c        ****       if( IS_SET(state,LED_EN) || (IS_SET(state,SET_LED_DIRECT) && IS_SET(state,TOUCHED)) ){
 247               		.loc 1 145 0
 248 00ee 80A0      		lds r24,state
 249 00f0 90E0      		ldi r25,lo8(0)
 250 00f2 81FD      		sbrc r24,1
 251 00f4 00C0      		rjmp .L8
 110:main.c        **** int main(void) {
 252               		.loc 1 110 0 discriminator 1
 253 00f6 8C70      		andi r24,lo8(12)
 254 00f8 9070      		andi r25,hi8(12)
 145:main.c        ****       if( IS_SET(state,LED_EN) || (IS_SET(state,SET_LED_DIRECT) && IS_SET(state,TOUCHED)) ){
 255               		.loc 1 145 0 discriminator 1
 256 00fa 8C30      		cpi r24,12
 257 00fc 9107      		cpc r25,__zero_reg__
 258 00fe 01F4      		brne .L9
 259               	.L8:
 147:main.c        ****           SET(DDRB,LED_PIN);
 260               		.loc 1 147 0
 261 0100 089A      		sbi 1-0,0
 148:main.c        ****           CLR(PUEB,LED_PIN);
 262               		.loc 1 148 0
 263 0102 1898      		cbi 3-0,0
 264 0104 00C0      		rjmp .L12
 265               	.L9:
 151:main.c        ****           CLR(DDRB,LED_PIN);
 266               		.loc 1 151 0
 267 0106 0898      		cbi 1-0,0
 152:main.c        ****           SET(PUEB,LED_PIN);
 268               		.loc 1 152 0
 269 0108 189A      		sbi 3-0,0
 270 010a 00C0      		rjmp .L12
 271               		.cfi_endproc
 272               	.LFE6:
 274               		.text
 275               	.global	__vector_1
 277               	__vector_1:
 278               	.LFB8:
 198:main.c        **** 
 199:main.c        **** 
 200:main.c        **** 
 201:main.c        **** 
 202:main.c        **** //=====================================
 203:main.c        **** //INTERRUPT HANDLERS
 204:main.c        **** //=====================================
 205:main.c        **** 
 206:main.c        **** //external interrupt (start of UART RX)
 207:main.c        **** ISR(INT0_vect){
 279               		.loc 1 207 0
 280               		.cfi_startproc
 281 003e 1F93      		push r17
 282               	.LCFI4:
 283               		.cfi_def_cfa_offset 3
 284               		.cfi_offset 17, -2
 285 0040 0F93      		push r16
 286               	.LCFI5:
 287               		.cfi_def_cfa_offset 4
 288               		.cfi_offset 16, -3
 289 0042 0FB7      		in r16,__SREG__
 290 0044 0F93      		push r16
 291 0046 10E0      		ldi __zero_reg__,lo8(0)
 292 0048 8F93      		push r24
 293               	.LCFI6:
 294               		.cfi_def_cfa_offset 5
 295               		.cfi_offset 24, -4
 296 004a 9F93      		push r25
 297               	.LCFI7:
 298               		.cfi_def_cfa_offset 6
 299               		.cfi_offset 25, -5
 300               	/* prologue: Signal */
 301               	/* frame size = 0 */
 302               	/* stack size = 5 */
 303               	.L__stack_usage = 5
 208:main.c        **** 
 209:main.c        ****     //allow touch to interrupt
 210:main.c        ****     sei();
 304               		.loc 1 210 0
 305               	/* #APP */
 306               	 ;  210 "main.c" 1
 307 004c 7894      		sei
 308               	 ;  0 "" 2
 211:main.c        **** 
 212:main.c        ****     //set first sample time
 213:main.c        ****     OCR0A = TCNT0+UART_HALF_OCR_INC;
 309               		.loc 1 213 0
 310               	/* #NOAPP */
 311 004e 88B5      		in r24,40-0
 312 0050 99B5      		in r25,40+1-0
 313 0052 8D56      		subi r24,lo8(-(403))
 314 0054 9E4F      		sbci r25,hi8(-(403))
 315 0056 97BD      		out 38+1-0,r25
 316 0058 86BD      		out 38-0,r24
 214:main.c        ****     //disable external interrupt, enable COMPA interrupt
 215:main.c        ****     CLR(EIMSK,INT0);
 317               		.loc 1 215 0
 318 005a 9898      		cbi 19-0,0
 216:main.c        ****     SET(TIMSK0,OCIE0B);
 319               		.loc 1 216 0
 320 005c 8BB5      		in r24,43-0
 321 005e 8460      		ori r24,lo8(4)
 322 0060 8BBD      		out 43-0,r24
 323               	/* epilogue start */
 217:main.c        **** 
 218:main.c        **** }
 324               		.loc 1 218 0
 325 0062 9F91      		pop r25
 326 0064 8F91      		pop r24
 327 0066 0F91      		pop r16
 328 0068 0FBF      		out __SREG__,r16
 329 006a 0F91      		pop r16
 330 006c 1F91      		pop r17
 331 006e 1895      		reti
 332               		.cfi_endproc
 333               	.LFE8:
 335               	.global	__vector_6
 337               	__vector_6:
 338               	.LFB9:
 219:main.c        **** 
 220:main.c        **** 
 221:main.c        **** 
 222:main.c        **** 
 223:main.c        **** //OCR0A interrupt handler
 224:main.c        **** ISR(TIM0_COMPB_vect){
 339               		.loc 1 224 0
 340               		.cfi_startproc
 341 0070 1F93      		push r17
 342               	.LCFI8:
 343               		.cfi_def_cfa_offset 3
 344               		.cfi_offset 17, -2
 345 0072 0F93      		push r16
 346               	.LCFI9:
 347               		.cfi_def_cfa_offset 4
 348               		.cfi_offset 16, -3
 349 0074 0FB7      		in r16,__SREG__
 350 0076 0F93      		push r16
 351 0078 10E0      		ldi __zero_reg__,lo8(0)
 352 007a 6F93      		push r22
 353               	.LCFI10:
 354               		.cfi_def_cfa_offset 5
 355               		.cfi_offset 22, -4
 356 007c 8F93      		push r24
 357               	.LCFI11:
 358               		.cfi_def_cfa_offset 6
 359               		.cfi_offset 24, -5
 360 007e 9F93      		push r25
 361               	.LCFI12:
 362               		.cfi_def_cfa_offset 7
 363               		.cfi_offset 25, -6
 364               	/* prologue: Signal */
 365               	/* frame size = 0 */
 366               	/* stack size = 6 */
 367               	.L__stack_usage = 6
 225:main.c        **** 
 226:main.c        ****     //allow touch to interrupt
 227:main.c        ****     sei();
 368               		.loc 1 227 0
 369               	/* #APP */
 370               	 ;  227 "main.c" 1
 371 0080 7894      		sei
 372               	 ;  0 "" 2
 228:main.c        **** 
 229:main.c        ****     //update OCR0A (always to reduce jitter)
 230:main.c        ****     OCR0A += UART_OCR_INC;
 373               		.loc 1 230 0
 374               	/* #NOAPP */
 375 0082 86B5      		in r24,38-0
 376 0084 97B5      		in r25,38+1-0
 377 0086 8E53      		subi r24,lo8(-(194))
 378 0088 9F4F      		sbci r25,hi8(-(194))
 379 008a 97BD      		out 38+1-0,r25
 380 008c 86BD      		out 38-0,r24
 231:main.c        **** 
 232:main.c        ****     //update RX and TX
 233:main.c        ****     if(tx_cnt == UART_START){
 381               		.loc 1 233 0
 382 008e 80A0      		lds r24,tx_cnt
 383 0090 8823      		tst r24
 384 0092 01F4      		brne .L15
 234:main.c        ****         //don't store sample, set TX low
 235:main.c        ****         CLR(PORTB,UART_TX_PIN);
 385               		.loc 1 235 0
 386 0094 1398      		cbi 2-0,3
 236:main.c        ****         //icrement tx counter
 237:main.c        ****         tx_cnt++;
 387               		.loc 1 237 0
 388 0096 81E0      		ldi r24,lo8(1)
 389 0098 00C0      		rjmp .L25
 390               	.L15:
 238:main.c        ****     } else if (tx_cnt < UART_STOP) {
 391               		.loc 1 238 0
 392 009a 8930      		cpi r24,lo8(9)
 393 009c 00F4      		brsh .L17
 394 009e 80A0      		lds r24,cur_rx
 239:main.c        ****         //store RX samle
 240:main.c        ****         COPY_BIT(PINB,UART_RX_PIN,cur_rx,0x00);
 395               		.loc 1 240 0
 396 00a0 029B      		sbis 0-0,2
 397 00a2 00C0      		rjmp .L18
 398               		.loc 1 240 0 is_stmt 0 discriminator 1
 399 00a4 8160      		ori r24,lo8(1)
 400 00a6 00C0      		rjmp .L24
 401               	.L18:
 402               		.loc 1 240 0 discriminator 2
 403 00a8 8E7F      		andi r24,lo8(-2)
 404               	.L24:
 405 00aa 80A8      		sts cur_rx,r24
 241:main.c        ****         cur_rx = (cur_rx << 1);
 406               		.loc 1 241 0 is_stmt 1 discriminator 2
 407 00ac 80A0      		lds r24,cur_rx
 408 00ae 880F      		lsl r24
 409 00b0 80A8      		sts cur_rx,r24
 242:main.c        ****         //set TX output
 243:main.c        ****         COPY_BIT(cur_tx,0,PORTB,UART_TX_PIN);
 410               		.loc 1 243 0 discriminator 2
 411 00b2 80A0      		lds r24,cur_tx
 412 00b4 80FF      		sbrs r24,0
 413 00b6 00C0      		rjmp .L20
 414               		.loc 1 243 0 is_stmt 0 discriminator 1
 415 00b8 139A      		sbi 2-0,3
 416 00ba 00C0      		rjmp .L21
 417               	.L20:
 418               		.loc 1 243 0 discriminator 2
 419 00bc 1398      		cbi 2-0,3
 420               	.L21:
 244:main.c        ****         cur_tx = (cur_tx >> 1);
 421               		.loc 1 244 0 is_stmt 1
 422 00be 8695      		lsr r24
 423 00c0 80A8      		sts cur_tx,r24
 245:main.c        ****         //increment tx counter
 246:main.c        ****         tx_cnt++;
 424               		.loc 1 246 0
 425 00c2 80A0      		lds r24,tx_cnt
 426 00c4 8F5F      		subi r24,lo8(-(1))
 427               	.L25:
 428 00c6 80A8      		sts tx_cnt,r24
 429 00c8 00C0      		rjmp .L14
 430               	.L17:
 247:main.c        ****     } else {
 248:main.c        ****         //don't sample, set TX high
 249:main.c        ****         SET(PORTB,UART_TX_PIN);
 431               		.loc 1 249 0
 432 00ca 139A      		sbi 2-0,3
 250:main.c        ****         //disable this interrupt until next RX byte
 251:main.c        ****         CLR(TIMSK0,OCIE0B);
 433               		.loc 1 251 0
 434 00cc 8BB5      		in r24,43-0
 435 00ce 8B7F      		andi r24,lo8(-5)
 436 00d0 8BBD      		out 43-0,r24
 252:main.c        ****         //we are done, set tx_counter to 0
 253:main.c        ****         tx_cnt = 0x00;
 437               		.loc 1 253 0
 438 00d2 10A8      		sts tx_cnt,__zero_reg__
 254:main.c        **** 
 255:main.c        ****         //cur_rx done, check if message is for us
 256:main.c        ****         if( IS_SET(cur_rx,MSG_SLOT_TAKEN) && IS_SET(state,TAKEN_PASSED) ){
 439               		.loc 1 256 0
 440 00d4 80A0      		lds r24,cur_rx
 441 00d6 80FF      		sbrs r24,0
 442 00d8 00C0      		rjmp .L22
 443               		.loc 1 256 0 is_stmt 0 discriminator 1
 444 00da 90A0      		lds r25,state
 445 00dc 90FF      		sbrs r25,0
 446 00de 00C0      		rjmp .L22
 257:main.c        **** 
 258:main.c        ****             //if for us, store settings, refresh button state
 259:main.c        ****             state = (cur_rx & ~CONF_BIT_MASK) | (state & CONF_BIT_MASK);
 447               		.loc 1 259 0 is_stmt 1
 448 00e0 9971      		andi r25,lo8(25)
 449 00e2 682F      		mov r22,r24
 450 00e4 667E      		andi r22,lo8(-26)
 451 00e6 962B      		or r25,r22
 260:main.c        ****             cur_tx = cur_rx | B(MSG_SLOT_TAKEN) | (state & B(TOUCHED));
 452               		.loc 1 260 0
 453 00e8 692F      		mov r22,r25
 454 00ea 6870      		andi r22,lo8(8)
 455 00ec 8160      		ori r24,lo8(1)
 456 00ee 682B      		or r22,r24
 457 00f0 60A8      		sts cur_tx,r22
 261:main.c        ****             //update state flags
 262:main.c        ****             state &= ~B(TAKEN_PASSED) & ~B(TOUCHED);
 458               		.loc 1 262 0
 459 00f2 967F      		andi r25,lo8(-10)
 460 00f4 90A8      		sts state,r25
 263:main.c        ****             //set led PWM output based on new config (only control upper bits, rest 1)
 264:main.c        ****             OCR0AH = ~CONF_LED_MASK | state;
 461               		.loc 1 264 0
 462 00f6 9F61      		ori r25,lo8(31)
 463 00f8 97BD      		out 39-0,r25
 265:main.c        ****             OCR0AL = 0xFF;
 464               		.loc 1 265 0
 465 00fa 8FEF      		ldi r24,lo8(-1)
 466 00fc 86BD      		out 38-0,r24
 467 00fe 00C0      		rjmp .L23
 468               	.L22:
 266:main.c        **** 
 267:main.c        ****         } else {
 268:main.c        ****             //if not for us pass on untouched
 269:main.c        ****             cur_tx = cur_rx;
 469               		.loc 1 269 0
 470 0100 80A8      		sts cur_tx,r24
 471               	.L23:
 270:main.c        ****         }
 271:main.c        **** 
 272:main.c        ****         //go to uart idle state (enable EXTI)
 273:main.c        ****         cur_rx = 0x00;
 472               		.loc 1 273 0
 473 0102 10A8      		sts cur_rx,__zero_reg__
 274:main.c        ****         EIFR  = (1<<INTF0);
 474               		.loc 1 274 0
 475 0104 81E0      		ldi r24,lo8(1)
 476 0106 84BB      		out 20-0,r24
 275:main.c        ****         EIMSK = (1 << INT0);
 477               		.loc 1 275 0
 478 0108 83BB      		out 19-0,r24
 479               	.L14:
 480               	/* epilogue start */
 276:main.c        ****     }
 277:main.c        **** 
 278:main.c        **** }
 481               		.loc 1 278 0
 482 010a 9F91      		pop r25
 483 010c 8F91      		pop r24
 484 010e 6F91      		pop r22
 485 0110 0F91      		pop r16
 486 0112 0FBF      		out __SREG__,r16
 487 0114 0F91      		pop r16
 488 0116 1F91      		pop r17
 489 0118 1895      		reti
 490               		.cfi_endproc
 491               	.LFE9:
 493               	.global	__vector_4
 495               	__vector_4:
 496               	.LFB10:
 279:main.c        **** 
 280:main.c        **** 
 281:main.c        **** 
 282:main.c        **** #if LED_PIN != PIN0
 283:main.c        **** #  error "change interrupt routines when changing LED_PIN definition"
 284:main.c        **** #endif
 285:main.c        **** #if TOUCH_PIN != PIN1
 286:main.c        **** #  error "change interrupt routines when changing TOUCH_PIN definition"
 287:main.c        **** #endif
 288:main.c        **** 
 289:main.c        **** //TIM0 overflow handler,
 290:main.c        **** //Start touch measurement by setting pin to input
 291:main.c        **** //also clear led pin, for PWM (pwm mode does not allow 0xFFFF as top....)
 292:main.c        **** ISR(TIM0_OVF_vect, ISR_NAKED){
 497               		.loc 1 292 0
 498               		.cfi_startproc
 499               	/* prologue: naked */
 500               	/* frame size = 0 */
 501               	/* stack size = 0 */
 502               	.L__stack_usage = 0
 293:main.c        ****     //set cap_touch pin to input pin to input
 294:main.c        ****     //PORTB &= ~(1 << LED_PIN);
 295:main.c        ****     //DDRB &= ~(1 << TOUCH_PIN);
 296:main.c        ****     asm("cbi 2,0");
 503               		.loc 1 296 0
 504               	/* #APP */
 505               	 ;  296 "main.c" 1
 506 011a 1098      		cbi 2,0
 507               	 ;  0 "" 2
 297:main.c        ****     asm("cbi 1,1");
 508               		.loc 1 297 0
 509               	 ;  297 "main.c" 1
 510 011c 0998      		cbi 1,1
 511               	 ;  0 "" 2
 298:main.c        ****     asm("reti");
 512               		.loc 1 298 0
 513               	 ;  298 "main.c" 1
 514 011e 1895      		reti
 515               	 ;  0 "" 2
 516               	/* epilogue start */
 299:main.c        **** }
 517               		.loc 1 299 0
 518               	/* #NOAPP */
 519               		.cfi_endproc
 520               	.LFE10:
 522               	.global	__vector_5
 524               	__vector_5:
 525               	.LFB11:
 300:main.c        **** 
 301:main.c        **** 
 302:main.c        **** //kind of stupid, but needed since non-pwm mode makes PWM generation hard
 303:main.c        **** //cannot set to PWM mode because the TOP values are either changing
 304:main.c        **** //OC0A, OC0B and ICR, or TOP value is too low (0x03FF max).
 305:main.c        **** ISR(TIM0_COMPA_vect, ISR_NAKED){
 526               		.loc 1 305 0
 527               		.cfi_startproc
 528               	/* prologue: naked */
 529               	/* frame size = 0 */
 530               	/* stack size = 0 */
 531               	.L__stack_usage = 0
 306:main.c        ****     //set cap_touch pin to input pin to input
 307:main.c        ****     //PORTB &= ~(1 << LED_PIN);
 308:main.c        ****     //DDRB &= ~(1 << TOUCH_PIN);
 309:main.c        ****     asm("sbi 2,0");
 532               		.loc 1 309 0
 533               	/* #APP */
 534               	 ;  309 "main.c" 1
 535 0120 109A      		sbi 2,0
 536               	 ;  0 "" 2
 310:main.c        ****     asm("reti");
 537               		.loc 1 310 0
 538               	 ;  310 "main.c" 1
 539 0122 1895      		reti
 540               	 ;  0 "" 2
 541               	/* epilogue start */
 311:main.c        **** }
 542               		.loc 1 311 0
 543               	/* #NOAPP */
 544               		.cfi_endproc
 545               	.LFE11:
 547               		.comm touch_avg,2,1
 548               		.comm touch_new,2,1
 549               		.comm touch_cnt,1,1
 550               		.comm led_val,1,1
 551               		.comm state,1,1
 552               		.comm tx_cnt,1,1
 553               		.comm cur_tx,1,1
 554               		.comm cur_rx,1,1
 555               		.comm cur_touch,1,1
 556               		.comm cur_conf,1,1
 557               		.comm cur_meas,2,1
 558               	.Letext0:
 559               		.file 2 "/opt/cross/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccZfsSfI.s:2      *ABS*:000000000000003f __SREG__
     /tmp/ccZfsSfI.s:3      *ABS*:000000000000003e __SP_H__
     /tmp/ccZfsSfI.s:4      *ABS*:000000000000003d __SP_L__
     /tmp/ccZfsSfI.s:5      *ABS*:000000000000003c __CCP__
     /tmp/ccZfsSfI.s:6      *ABS*:0000000000000010 __tmp_reg__
     /tmp/ccZfsSfI.s:7      *ABS*:0000000000000011 __zero_reg__
     /tmp/ccZfsSfI.s:15     .text:0000000000000000 init
                            *COM*:0000000000000002 touch_avg
                            *COM*:0000000000000001 cur_rx
     /tmp/ccZfsSfI.s:87     .text.startup:0000000000000000 main
                            *COM*:0000000000000002 touch_new
                            *COM*:0000000000000001 touch_cnt
                            *COM*:0000000000000001 state
     /tmp/ccZfsSfI.s:277    .text:000000000000003e __vector_1
     /tmp/ccZfsSfI.s:337    .text:0000000000000070 __vector_6
                            *COM*:0000000000000001 tx_cnt
                            *COM*:0000000000000001 cur_tx
     /tmp/ccZfsSfI.s:495    .text:000000000000011a __vector_4
     /tmp/ccZfsSfI.s:524    .text:0000000000000120 __vector_5
                            *COM*:0000000000000001 led_val
                            *COM*:0000000000000001 cur_touch
                            *COM*:0000000000000001 cur_conf
                            *COM*:0000000000000002 cur_meas

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
